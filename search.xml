<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[HDU5763]Another Meaning]]></title>
    <url>%2F2019%2F02%2F23%2FHDU5763-Another-Meaning%2F</url>
    <content type="text"><![CDATA[话说这道题考场上把我弄自闭了 $KMP$板子有点忘记了，强行回忆了一波 然后突然发现不会计数。。。 不会$DP$的我就自闭了，其实这题$DP$式子不是一般的简单 先把子串的$Fail$指针预处理出来 然后在母串中匹配出子串的位置 最后进行$DP$计数，转移方程$F$$[$$i$$]$$=$$F$$[$$i-1$$]$$+$$F$$[$$i-m$$]$ 其中$i$是母串中成功匹配的位置，$m$为子串的长度 因为每匹配一次子串，都会带来新的意思，加上这个子串的方案数即可 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;char s[200002];char t[200002];int m,n,T;int f[200002];int fail[200002];int main()&#123; freopen("meaning.in","r",stdin); freopen("meaning.out","w",stdout); scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",s+1,t+1); n=strlen(s+1);m=strlen(t+1); for(register int i=2;i&lt;=m;++i) &#123; int j=fail[i-1]; while(j&amp;&amp;t[j+1]!=t[i]) j=fail[j]; if(t[j+1]==t[i]) ++j; fail[i]=j; &#125; f[0]=1; for(register int i=1,j=0;i&lt;=n;++i) &#123; while(j&amp;&amp;s[i]!=t[j+1]) j=fail[j]; if(s[i]==t[j+1]) ++j; if(j==m) j=fail[j],f[i]=f[i-m]; f[i]+=f[i-1]; f[i]-=f[i]&gt;=mod?mod:0; &#125; printf("%d\n",f[n]); memset(f,0,sizeof(f)); memset(fail,0,sizeof(fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[IOI2000]回文字串]]></title>
    <url>%2F2019%2F02%2F23%2FIOI2000-%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[今天模拟赛三道动态规划，这是最简单的一道 考试的时候想的是贪心，大力分类讨论一波以为能过 考完才知道正解就是一道最长公共子序列？？？ 这个跟回文串的性质有关，它正着读和倒着读是完全一样的 这样的话我们就可以把原串反过来跟它自己匹配 最后的答案就是原串的长度减去匹配的长度 考完才发现我不会打最长公共子序列 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;char s1[10086];char s2[10086];int f[5005][5005];int n,ans;int main()&#123; scanf("%s",s1+1);n=strlen(s1+1); for(register int i=1;i&lt;=n;++i) s2[n-i+1]=s1[i]; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(s1[i]==s2[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); ans=n-f[n][n]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3378]堆]]></title>
    <url>%2F2019%2F02%2F22%2FLuogu3378-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[因为是模板题所以就只贴代码 学习笔记戳这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int heap[1000001];int m,n,x,size;inline void put(int y)&#123; int now,next; heap[++size]=y; now=size; while(now&gt;1) &#123; next=now&gt;&gt;1; if(heap[now]&gt;=heap[next]) break; swap(heap[now],heap[next]); now=next; &#125;&#125;inline void get()&#123; int now,next; heap[1]=heap[size--]; now=1; while(now*2&lt;=size) &#123; next=now*2; if(next&lt;size&amp;&amp;heap[next+1]&lt;heap[next]) next++; if(heap[now]&lt;=heap[next]) break; swap(heap[now],heap[next]); now=next; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;m); if(m==1) &#123; scanf("%d",&amp;x); put(x); &#125; if(m==2) printf("%d\n",heap[1]); if(m==3) get(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈手打堆]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%B5%85%E8%B0%88%E6%89%8B%E6%89%93%E5%A0%86%2F</url>
    <content type="text"><![CDATA[故事的起因很有趣，还是去年的事了 $Noip2018$之前谢骚说他不会手打堆？？？ 我当时就一句这么简单的东西怎么不会 然后他就因为这个一直膜我到现在 那时候就有了写一写手打堆的念头 只是因为谢骚$Noip2018$混到一等之后功成身退，所以就一直咕到现在 堆，一般指的是小根堆，它是一颗完全二叉树 它满足一个性质，父亲的权值不大于儿子的权值 由于这个性质，树根存的就是最小值 这里我们来看一下堆的两种操作 插入操作 为了保证插入后也是一棵完全二叉树，我们从最下面一层最右边的叶子节点后面插入 如果最下面一层已满，就新增一层再从最左边开始插入 如果这个结点的权值大于它父亲的权值，就进行交换 直到不满足或者已经到根节点就停止，那么插入操作的复杂度就是$logn$的 删除操作 先把根节点与最后一个节点交换，再删除最后一个节点 如果根节点的权值大于它的儿子的权值，就进行交换 这里究竟是左儿子还是右儿子需要分类讨论一下 直到不满足或者已经到最下面一层就停止，那么删除操作的复杂度就是$logn$的 实际上各种操作都是建立在向上向下交换的基础上的 其实学这玩意还不如用$STL$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.3]修理牛棚 Barn Repair]]></title>
    <url>%2F2019%2F02%2F21%2FUSACO1-3-%E4%BF%AE%E7%90%86%E7%89%9B%E6%A3%9A-Barn-Repair%2F</url>
    <content type="text"><![CDATA[代码应该算是比较简练的 首先可以考虑贪心，而且是$O$ $($ $m$ $)$的贪心 然后再来思考一下贪心策略 这道题其实比较适合反向思维，思考难度因人而异 就是先确定一大块板，再去把它分成很多块小板 具体的来说就是从第一个牛棚到最后一个牛棚 因为这段区间的长度是一定的 又因为总共要覆盖$m$块木板,所以中间最多只能有$m$ $-$ $1$块空隙 所以我们只要找出$m$ $-$ $1$块最大的空隙，以确保木板总长度最短 所以我们可以使用两遍快速排序 第一遍排序牛棚，确定区间的长度 第二遍排序空隙，求出最长的$m$ $-$ $1$块空隙 然后依次减去最长的$m$ $-$ $1$块空隙就是所得的答案 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int w[222];int y[222];int c,m,s,ans;int main()&#123; scanf("%d%d%d",&amp;m,&amp;s,&amp;c); for(register int i=1;i&lt;=c;++i) scanf("%d",&amp;w[i]); if(m&gt;=c) ans=c; else &#123; sort(w+1,w+c+1); ans=w[c]-w[1]+1; for(register int i=1;i&lt;=c-1;++i) y[i]=w[i+1]-w[i]-1; sort(y+1,y+c); for(register int i=c-1;i&gt;=c-m+1;--i) ans-=y[i]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.2]命名那个数字 Name That Number]]></title>
    <url>%2F2019%2F02%2F21%2FUSACO1-2-%E5%91%BD%E5%90%8D%E9%82%A3%E4%B8%AA%E6%95%B0%E5%AD%97-Name-That-Number%2F</url>
    <content type="text"><![CDATA[这道题好像$AC$人数有点少啊 严格意义上来说，这道题是一道水题 就是把名字库转换成数字库，然后暴力匹配即可 但是我同桌提出了一种神奇的暴力 可以很好的锻炼码力，但是可能对新人不太友好 那么的话身为他同桌的我还是帮他填这个坑 跟其他玄学做法相比，其实思维难度真心不大 首先，我们可以先将数字转换成可以用的名字 然后用这些名字去可以选用的名字中匹配 然而这样的最坏复杂度是多少？？？ 卧槽竟然是一个常数。。。 怎么都感觉过不了，然而好像真的有人卡过去了。。。 不知道是数据太水还是$ta$太强了 所以显然是不能暴力匹配的，所以我们可以考虑二分 二分查找来缩小范围，然后就只需要匹配一个 二分的条件就是字典序匹配，从小到大 然而怎么最坏复杂度还是不对？？？ 不管了反正这题数据水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;char name[5005][15];char k[15];char s[15];bool flag;int m,n;char num[11][4]=&#123;&#123;&#125;,&#123;&#125;,&#123;'A','B','C'&#125;,&#123;'D','E','F'&#125;,&#123;'G','H','I'&#125;,&#123;'J','K','L'&#125;,&#123;'M','N','O'&#125;,&#123;'P','R','S'&#125;,&#123;'T','U','V'&#125;,&#123;'W','X','Y'&#125;&#125;;inline void Half()&#123; int l=1,r=4618,mid; while(l&lt;=r) &#123; mid=(l+r)/2; int lon=strlen(name[mid]); flag=true; for(register int i=0;i&lt;n||i&lt;lon;++i) &#123; if(name[mid][i]&lt;k[i]) &#123; l=mid+1; flag=false; break; &#125; if(name[mid][i]&gt;k[i]) &#123; r=mid-1; flag=false; break; &#125; &#125; if(flag) break; &#125; if(strlen(name[mid])!=n) return ; for(register int i=0;i&lt;n;++i) if(name[mid][i]!=k[i]) return ; printf("%s\n",k); ++m;&#125;inline void Dfs(int z)&#123; if(z==n) &#123; Half(); return ; &#125; else &#123; int now=s[z]-'0'; for(register int i=0;i&lt;=2;++i) &#123; k[z]=num[now][i]; Dfs(z+1); &#125; &#125;&#125;int main()&#123; scanf("%s",s); for(register int i=1;i&lt;=4617;++i) scanf("%s",name[i]); n=strlen(s); Dfs(0); if(m==0) puts("NONE"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.2]方块转换 Transformations]]></title>
    <url>%2F2019%2F02%2F19%2FUSACO1-2-%E6%96%B9%E5%9D%97%E8%BD%AC%E6%8D%A2-Transformations%2F</url>
    <content type="text"><![CDATA[一道大模拟又被我打出了160行 还好一次A掉不至于当场去世 毫无技术含量可言 只要基本懂字符串就行 首先，翻转$90$、$180$、$270$其实等于一个操作 就是写一个翻转$90$函数用三遍而已 翻转转移方程可以手玩一下 就是$s$[$i$] [$j$]=s[$n$-$j$+$1$][$i$]，还是比较好推的 然后写一次对称过来，再用三次翻转$90$函数 最后再看是不是和初始状态相同 建议每变化一次就去验证一次 如果成功就直接$return$ $0$，简单粗暴 下面一些题外话 大家做这种题一定要细心 哪怕你压行也要尽量控制代码长度 不然考场上真的很难查错，也很浪费时间 本人天生反面教材 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;using namespace std;char s[11][11];char x[11][11];char y[11][11];char z[11][11];bool flag;int n,ans;inline void C()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) y[i][j]=x[n-j+1][i];&#125;inline void M()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) x[i][j]=y[i][j];&#125;inline void V()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) y[i][j]=x[i][n-j+1];&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; for(register int j=1;j&lt;=n;++j) &#123; cin&gt;&gt;s[i][j]; x[i][j]=s[i][j]; &#125; getchar(); &#125; for(register int i=1;i&lt;=n;++i) &#123; for(register int j=1;j&lt;=n;++j) cin&gt;&gt;z[i][j]; getchar(); &#125; C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("1"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("2"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("3"); return 0; &#125; else &#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) x[i][j]=s[i][j]; &#125; V();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("4"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(s[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) puts("6"); else puts("7"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.1]坏掉的项链Broken Necklace]]></title>
    <url>%2F2019%2F02%2F19%2FUSACO1-1-%E5%9D%8F%E6%8E%89%E7%9A%84%E9%A1%B9%E9%93%BEBroken-Necklace%2F</url>
    <content type="text"><![CDATA[话说$USACO$的水题质量挺高的，好像真的是这样 这道题当时我可是调了一个下午的 这题暴力能过，复杂度就懒得算了 不需要什么思路，直接上模拟 就是枚举断开位置，然后分别往两边找 找到不能再找就停下，看看是否可以更新答案 需要特别提醒的是断开位置两边是$w$的情况 那就需要继续找到第一个不是$w$的位置 用这个位置上的字符去判断 然后就被我硬生生的打出了一道大模拟 别人平均$60$行，我打出了$160$行？？？ 心态崩了，我要妹子 看来我还是太菜了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;char a,b;char s[404];bool t[404];int n,l,r,ans,sum;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) cin&gt;&gt;s[i]; memset(t,false,sizeof(t)); a=s[1];b=s[n]; if(a=='w') &#123; for(register int i=1;i&lt;=n;++i) if(s[i]!='w') &#123; a=s[i]; break; &#125; &#125; if(b=='w') &#123; for(register int i=n;i&gt;=1;--i) if(s[i]!='w') &#123; b=s[i]; break; &#125; &#125; for(register int i=1;i&lt;=n;++i) if(s[i]==a||s[i]=='w') t[i]=true; else break; for(register int i=n;i&gt;=1;--i) if(s[i]==b||s[i]=='w') t[i]=true; else break; for(register int i=1;i&lt;=n;++i) if(t[i]) ++ans; for(register int i=1;i&lt;=n-1;++i) &#123; memset(t,false,sizeof(t)); a=s[i];b=s[i+1];sum=0; if(a=='w') &#123; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; else &#123; for(register int k=n;k&gt;=i+1;--k) if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; &#125; if(b=='w') &#123; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; else &#123; for(register int k=1;k&lt;=i;++k) if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; &#125; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]==a||s[j]=='w') &#123; t[j]=true; for(register int k=n;k&gt;=i+1;--k) if(s[k]==a||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==a||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]==b||s[j]=='w') &#123; t[j]=true; for(register int k=1;k&lt;=i;++k) if(s[k]==b||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==b||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=1;j&lt;=n;++j) if(t[j]) ++sum; ans=max(ans,sum); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
