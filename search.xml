<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[USACO1.1]坏掉的项链Broken Necklace]]></title>
    <url>%2F2019%2F02%2F19%2FUSACO1-1-%E5%9D%8F%E6%8E%89%E7%9A%84%E9%A1%B9%E9%93%BEBroken-Necklace%2F</url>
    <content type="text"><![CDATA[话说$USACO$的水题质量挺高的，好像真的是这样 这道题当时我可是调了一个下午的 这题暴力能过，复杂度就懒得算了 不需要什么思路，直接上模拟 就是枚举断开位置，然后分别往两边找 找到不能再找就停下，看看是否可以更新答案 需要特别提醒的是断开位置两边是$w$的情况 那就需要继续找到第一个不是$w$的位置 用这个位置上的字符去判断 然后就被我硬生生的打出了一道大模拟 别人平均$60$行，我打出了$160$行？？？ 心态崩了，我要妹子 看来我还是太菜了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;char a,b;char s[404];bool t[404];int n,l,r,ans,sum;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) cin&gt;&gt;s[i]; memset(t,false,sizeof(t)); a=s[1];b=s[n]; if(a=='w') &#123; for(register int i=1;i&lt;=n;++i) if(s[i]!='w') &#123; a=s[i]; break; &#125; &#125; if(b=='w') &#123; for(register int i=n;i&gt;=1;--i) if(s[i]!='w') &#123; b=s[i]; break; &#125; &#125; for(register int i=1;i&lt;=n;++i) if(s[i]==a||s[i]=='w') t[i]=true; else break; for(register int i=n;i&gt;=1;--i) if(s[i]==b||s[i]=='w') t[i]=true; else break; for(register int i=1;i&lt;=n;++i) if(t[i]) ++ans; for(register int i=1;i&lt;=n-1;++i) &#123; memset(t,false,sizeof(t)); a=s[i];b=s[i+1];sum=0; if(a=='w') &#123; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; else &#123; for(register int k=n;k&gt;=i+1;--k) if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; &#125; if(b=='w') &#123; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; else &#123; for(register int k=1;k&lt;=i;++k) if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; &#125; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]==a||s[j]=='w') &#123; t[j]=true; for(register int k=n;k&gt;=i+1;--k) if(s[k]==a||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==a||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]==b||s[j]=='w') &#123; t[j]=true; for(register int k=1;k&lt;=i;++k) if(s[k]==b||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==b||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=1;j&lt;=n;++j) if(t[j]) ++sum; ans=max(ans,sum); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
