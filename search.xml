<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[HAOI2008]硬币购物]]></title>
    <url>%2F2019%2F07%2F14%2FHAOI2008-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9%2F</url>
    <content type="text"><![CDATA[一边听课一边打摆 因为每次都做一次背包会$T$飞，考虑先不考虑限制预处理方案数 然后考虑限制，用总方案数减去不合法的方案数 第$i$种硬币要超出限制至少要用$d[i]+1$个 那么考虑限制之后不合法的方案数就是$F[s-c[i]*(d[i]+1)]$ 最后对硬币进行容斥，计算答案即可 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100007;int s,tot,c[4],d[4];long long f[maxn]=&#123;1&#125;;int main () &#123; for(register int i=0;i&lt;4;++i) scanf("%d",&amp;c[i]); for(register int i=0;i&lt;4;++i) for(register int j=c[i];j&lt;maxn;++j) f[j]+=f[j-c[i]]; scanf("%d",&amp;tot); while(tot--) &#123; for(register int i=0;i&lt;4;++i) scanf("%d",&amp;d[i]); scanf("%d",&amp;s); register long long ans=0; for(register int i=0;i&lt;16;++i) &#123; register int num=0; register long long sum=0; for(register int j=0;j&lt;4;++j) if(i&amp;(1&lt;&lt;j)) ++num,sum+=c[j]*(d[j]+1); if(s&lt;sum) continue ; ans+=(num&amp;1)?-f[s-sum]:f[s-sum]; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2010]能量采集]]></title>
    <url>%2F2019%2F07%2F14%2FNOI2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[鸽子终于更博了 考虑设$F[i]$为$i$是$m$和$n$公因数的方案数，显然$F[i]=(m/i)*(n/i)$ 然后对$i$进行容斥，就能得到$F[i]$为$i$是$m$和$n$最小公因数的方案数 最后套用公式，直接计算答案即可 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;long long m,n,k,ans,f[100001];int main () &#123; scanf("%lld%lld",&amp;n,&amp;m); k=min(m,n); for(register int i=k;i;--i) &#123; f[i]=(n/i)*(m/i); for(register int j=i+i;j&lt;=k;j+=i) f[i]-=f[j]; (ans+=(i*2-1)*f[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2014]DOO-Around the world]]></title>
    <url>%2F2019%2F07%2F14%2FPOI2014-DOO-Around-the-world%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3943]星空]]></title>
    <url>%2F2019%2F05%2F11%2FLuogu3943-%E6%98%9F%E7%A9%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3942]将军令]]></title>
    <url>%2F2019%2F04%2F26%2FLuogu3942-%E5%B0%86%E5%86%9B%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一道难度适中的小清新乱搞好题 这题的正解是贪心，不过我好像$Hack$了正解 贪心策略好像还是比较简单的 找到当前没被覆盖的深度最深的点 然后找到它的$K$级父亲，往周围标记距离在$K$以内的点 如果有更优的标记，即离每次开始标记的点更近 那么就暴力更新标记，知道全部的点都被标记为止 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200002;int n,k,t,ans,cnt,f[maxn],Q[maxn],fa[maxn],to[maxn],from[maxn],head[maxn];inline void add(int u,int v) &#123; from[++cnt]=head[u]; to[cnt]=v; head[u]=cnt;&#125;inline void bfs() &#123; Q[1]=1; fa[1]=1; int he=1,ta=2; while(he&lt;ta) &#123; int x=Q[he++]; for(register int i=head[x];i;i=from[i]) if(!fa[to[i]]) fa[to[i]]=x,Q[ta++]=to[i]; &#125;&#125;inline int read() &#123; char ch=getchar(); int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;inline void update(int x) &#123; if(!fa[x]) return ; for(register int i=head[x];i;i=from[i]) if(f[x]-1&gt;f[to[i]]) &#123; f[to[i]]=f[x]-1; update(to[i]); &#125;&#125;int main() &#123; n=read(),k=read(),t=read(); for(register int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); add(u,v); add(v,u); &#125; bfs(); memset(f,-1,sizeof(f)); for(register int i=n;i;--i) &#123; if(f[Q[i]]==-1) &#123; ++ans; int x=Q[i]; for(register int j=k;j;--j) x=fa[x]; f[x]=k; update(x); &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3941]入阵曲]]></title>
    <url>%2F2019%2F04%2F26%2FLuogu3941-%E5%85%A5%E9%98%B5%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[一道难度适中的的小清新思维好题 我们先对原矩阵做一遍膜$K$意义下的前缀和 不难发现，膜$K$意义下前缀和相等的两个矩形 它们的前缀和的差一定是$K$的倍数 但是我们必须保证这两个矩形不重叠的部分一定是一个矩形 那么我们可以先枚举上下边界再枚举右边界 开一个桶依次记录膜$K$意义下的前缀和 最后根据每个数出现的次数计算贡献即可 特别要注意的是把桶清空的时候不能$memset$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;long long m,n,ans,mod;long long a[404][404],b[404],c[1000001];inline long long read() &#123; char ch=getchar(); long long num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;int main() &#123; n=read(),m=read(),mod=read(); for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) a[i][j]=read(),(a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+mod)%=mod; for(register int i=0;i&lt;n;++i) for(register int j=i+1;j&lt;=n;++j) &#123; c[0]=1; for(register int k=1;k&lt;=m;++k) b[k]=(a[j][k]-a[i][k]+mod)%mod,ans+=c[b[k]]++; for(register int k=1;k&lt;=m;++k) c[b[k]]=0; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu4556]雨天的尾巴]]></title>
    <url>%2F2019%2F04%2F14%2FLuogu4556-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4%2F</url>
    <content type="text"><![CDATA[这题给我的第一感觉就是树链剖分$+$树上差分，然而我不会 事实上主流做法确实是树链剖分，复杂度$O$$($$n$$logn^2$$)$ 然而这题还可以线段树合并，复杂度$O$$($$n$$logn$$)$ 但是跑得比树链剖分慢一倍，别问我为什么常数那么大 直接对每一个节点都维护一颗权值线段树 再套一个树上差分，最后直接线段树合并 因为这题空间卡得紧，所以离线操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int M=100001;const int N=8000008;int w,cnt,num,d[N],l[N],r[N],t[N],to[M&lt;&lt;1],from[M&lt;&lt;1];int X[M],Y[M],Z[M],fa[M],ans[M],son[M],sum[M],top[M],deep[M],head[M],root[M];inline void add(int u,int v) &#123; from[++num]=head[u]; to[num]=v; head[u]=num;&#125;inline int read() &#123; char ch=getchar(); int c=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) c=(c&lt;&lt;3)+(c&lt;&lt;1)+(ch^'0'),ch=getchar(); return c;&#125;inline void update(int x) &#123; if(d[l[x]]&gt;=d[r[x]]) d[x]=d[l[x]],t[x]=t[l[x]]; else d[x]=d[r[x]],t[x]=t[r[x]];&#125;inline int merge(int a,int b,int x,int y) &#123; if(!a) return b; if(!b) return a; if(x==y) &#123; d[a]+=d[b]; t[a]=x; return a; &#125; int mid=(x+y)&gt;&gt;1; l[a]=merge(l[a],l[b],x,mid),r[a]=merge(r[a],r[b],mid+1,y); update(a); return a;&#125;inline void Dfs1(int x) &#123; sum[x]=1; int maxx=-1; for(register int i=head[x];i;i=from[i]) if(!deep[to[i]]) &#123; deep[to[i]]=deep[x]+1,fa[to[i]]=x; Dfs1(to[i]); sum[x]+=sum[to[i]]; if(sum[to[i]]&gt;maxx) maxx=sum[to[i]],son[x]=to[i]; &#125;&#125;inline void Dfs2(int x,int topx) &#123; top[x]=topx; if(!son[x]) return ; Dfs2(son[x],topx); for(register int i=head[x];i;i=from[i]) if(!top[to[i]]) Dfs2(to[i],to[i]);&#125;inline int LCA(int x,int y) &#123; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return deep[x]&lt;deep[y]?x:y;&#125;inline int Change(int a,int x,int y,int pos,int val) &#123; if(!a) a=++cnt; if(x==y) &#123; d[a]+=val; t[a]=x; return a; &#125; int mid=(x+y)&gt;&gt;1; if(pos&lt;=mid) l[a]=Change(l[a],x,mid,pos,val); else r[a]=Change(r[a],mid+1,y,pos,val); update(a); return a;&#125;inline void ReDfs(int x) &#123; for(register int i=head[x];i;i=from[i]) if(deep[to[i]]&gt;deep[x]) ReDfs(to[i]),root[x]=merge(root[x],root[to[i]],1,w); if(d[root[x]]) ans[x]+=t[root[x]];&#125;int main() &#123; int n=read(),m=read(),x,y,z; for(register int i=1;i&lt;n;++i) x=read(),y=read(),add(x,y),add(y,x); deep[1]=1; Dfs1(1),Dfs2(1,1); for(register int i=1;i&lt;=m;++i) X[i]=read(),Y[i]=read(),Z[i]=read(),w=max(w,Z[i]); for(register int i=1;i&lt;=m;++i) &#123; int lca=LCA(X[i],Y[i]); root[X[i]]=Change(root[X[i]],1,w,Z[i],1),root[Y[i]]=Change(root[Y[i]],1,w,Z[i],1); root[lca]=Change(root[lca],1,w,Z[i],-1); if(fa[lca]) root[fa[lca]]=Change(root[fa[lca]],1,w,Z[i],-1); &#125; ReDfs(1); for(register int i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2019游记]]></title>
    <url>%2F2019%2F04%2F12%2FHNOI2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[省选结束了，大概是几家欢喜几家愁吧 $Day0$ 清明三天小长假的第一天，强制机房自习差评 心情有些烦，不太想做题，开始颓$PES$ 这种状态从没参加的安徽集训时开始，已经持续很久了 因为没人监督，所以颓得有点过分 有时候还和$Lyy$机房联机 半个月的时间就只搞了一点数学，成功把我搞自闭了 颓了一上午，下午捣鼓一下博客 晚上泊富吃饭，顺便逛了逛 回家之后没找到准考证，回学校机房找 最后准考证竟然是在我主机后面发现的 $Day1$ 早晨起得很早，去学校搭校车，竟然不是很困 校车迟到$10$分钟，问题不大 过去的路上是一个人坐，想一个人静一静 看着窗外熟悉的道路迷迷糊糊睡着了 醒来就快到$CSLG$了，司机飙车技术好评 刚睡醒有点困，赶紧灌了一口雀巢特浓 考场还是熟悉的考场，只不过这一次人好像少了许多 提前15分钟进考场，好像可以提前打配置 前面那一排用的都是$guide$，感觉很迷 开考之后先把题目看看了一遍，生怕开错题 没怎么仔细看所以看得很快 $T1$计算几何，$T2$字符串，$T3DP$ 决定先开$T2$，看了几遍题面确保没有读错题 撤销操作要查询历史版本，$KMP$套主席树 算了先码暴力$KMP$匹配，拿满暴力再说 突然发现自己忘了$KMP$怎么写 现场手推$KMP$可还行，这里可能浪费了两个小时 $T2$暴力写完还有两个多小时，心态没崩 接下来开$T1$，考前压根没复习计算几何 出去上个厕所呼吸一下新鲜空气 一堆人好像都还在爆肝$T1$？？？ 而且程序都莫名一样？？？ 怎么这么都多$for$循环？？？ 就这样我的思路被顺利地带偏了 又想了一下，好像可以枚举中轴线优化 好像有点难码，两个小时不一定能调出来 索性$O$$($$n^6$$)$，判角用的余弦定理 码完后死活调不出来，最后发现是$for$循环条件打错了 改完一发过样例，一看表还有$15$分钟 感觉这个$T3$不一定能骗得到分 拿出一堆零食，开始吃吃喝喝洗桑拿 吃着吃着就下考了，感觉今天发挥还算正常？？？ 出考场之后和大佬交流了一波 $Xmy$说$T1$可以$O$$($$n^2$$)$踩标算，$Lzk$说$T1$可以$O$$($$n^3$$)$吸氧卡常 我自闭了，这一个个都是要$AK$的节奏啊 下午回家睡不着觉，去$IFS$逛一逛 喝下午茶$+$看电影，调音师剧情好评 晚上听说成绩出了，就回机房去看一看 $T1$没挂分，$T2$爆零？？？ 后面发现我$T2$数组开小了。。。 特意看了一下，$Xmy$的$T1$只有$10$分，$Lzk$的$T1$只有$20$分 群里有人说他的$KMP$套主席树被卡到$20$分，$Xxz$的后缀自动机也只有$20$分 看来今天大家挂分都很严重 后排$6$人$generals$开黑可还行 问题不大，写了一下知乎回答，回家睡觉 $Day2$ 早上起早有些困，一上车就开始睡 睡醒就到了$CSLG$，还是困得不行 猛灌一大口雀巢特浓，全靠咖啡提神 还是先浏览了一遍题目，决定先开$T1$ $T1$感觉很迷，只能硬着头皮肝 没想出来什么暴力，最后深搜大剪枝 $T2$数论？？？题意好难理解 感觉这题出得太绕，出题人怕不是思维江化？？？ 稍微想了想，发现$n=1$的情况可以组合数计算贡献 然后开始码码码，码完自己手玩了几组样例 感觉正确就跳$T3$，$T3$感觉就像数据结构 深搜再用平均数剪一剪，感觉$10$分还是挺稳的 三题暴力码完大概还有$5$分钟，还是吃吃喝喝洗桑拿 不知不觉中我的第一次$HNOI$就这么结束了 下午回家吃完饭倒头就睡，一觉睡到五点 回学校机房看成绩，我今天爆零了？？？ 高二的学长有四个进队，好像$Jyx$也有希望进队？？？ $Zzs$把我们都赶回教室上晚自习，带着$Jyx$又去了$CSLG$ 晚自习和$Czz$聊得不亦乐乎，桌上作业堆得像山一样高 只写了语文数学，理性剪枝，怕是不想读书了 终于熬过了晚自习，跑到机房去了解一下情况 貌似后面又重测了一遍，还不分天算成绩？？？ $CCF$一年一个搞法？？？实在是不想吐槽$CCF$ $Jyx$貌似重测之后出队线了？？？不过应该有$D$吧 $T1$和$T3$挂了，因为今年$HNOI$的栈只有$8MB$ $T2$我至今没有找到$bug$，感觉最近码力直线下降 如果次次考试都这样挂分怕是真的要$AFO$ 毕竟马上我也快高二了，各种机会也都只有一次了 如果不想让自己后悔的话，那就自己好好努力吧 星光不问赶路人，时光不负有心人]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2019%2F04%2F05%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[明天就是省选，现在还在颓颓颓，珍惜最后的欢乐时光 $Day0$ 前一天晚上教练就作了安排，上午自习下午放假 不错不错，还算有点人性 一想起别人在考期中而我们在放假，还是比较开心的 上午主要就是看一看考试注意事项，$5$分钟就看完了 机房里面一堆人在打板子，看着就烦。。。 旁边$Zcy$喊我打$Slay$，人生第一次打$Slay$ 反正马上就考试了，也不在乎这些了 大考大玩，小考小玩 然后就这么颓废了一上午 中午我爸突然就过来了？？？ 本来下午还想出去玩的 在租的房子里睡了一个下午，现在睡觉都是一种奢侈 醒来之后从城北$CSYZ$跑到城南$MDZX$，去找$Jzh$ 请$Jzh$在外面吃了饭，再送他回学校上晚自习 $Jzh$还是一点也没没变，好兄弟一辈子 晚上回机房接着颓$Slay$ 我妈晚上也过来了，回家倒头就睡 可能白天颓得太狠，晚上有点失眠？？？ $Day1$ 起得特别早，到学校门口集合统一坐车前往$CSLG$ 老习惯又是一罐雀巢特浓顶着 上了车就开始奶人，旁边的$Wth$一度被我奶到怀疑人生 提前$20$分钟进了考场，第一次$NOIP$还是有点紧张的 监考老师提前$10$分钟给出了解压密码，然后我就解压开始写 $T1$正解不会，打的暴力 复杂度玄学，感觉没有这档分？？？ $T2$题意很难看懂啊，就是最少的数去凑全部的数 下意识就是一个暴搜？？？加上剪枝跑得飞快 $T3$有点懵，尝试骗分，鬼晓得我当时打了什么 出了考场就知道今天凉了，旁边一群大佬说什么今天大众分$255$ 下午又是睡一下午，晚上又去机房颓废一晚上 $Day2$ 路上不想奶人了，也没有那个心情 满脑子想的都是今天怎么翻盘 今天没有提前发解压密码，而且草稿纸一人只有一张，全程差评 $T1$又是暴搜，但是最后一个大样例死活过不去 鬼晓得$n$条边的情况就是暴力拆边。。。 $T2$我推了差不多两个小时，草稿纸早就没了 拿着一包纸巾打草稿可还行 差不多写完小半包纸巾，我感觉自己推出了一个$Fibonacci$。。。 当时也没仔细想就打了上去，乱推式子竟然没挂？？？ $T3$贪心过了大样例就不管了 总的来说发挥一般，考完之后心情还算好 下午去了趟$IFS$，记得上次来到这里还是中考结束 现在一转眼就半年了，半年的$OI$似乎很短暂，可能缘分也就到这里吧 考完强制滚粗补文化课，补到我都有点厌学 很多人$AFO$了,里面就有喊我颓$Slay$的$Zcy$ 我却踩线苟活下来了，那一刻心中真的是百感交集 他们天赋不比我差，也未必见得没我努力 那么能留下来的为什么就是我呢？我不知道 苟活者在淡红的血色中 会依稀看见微茫的希望 谨以此段缅怀那段一起为$NOIP2018$奋斗的岁月]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2006]超级英雄]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2006-%E8%B6%85%E7%BA%A7%E8%8B%B1%E9%9B%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]最长双回文串]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2008]树的统计]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2014]力]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2014-%E5%8A%9B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu4139]上帝和集合的正确用法]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu4139-%E4%B8%8A%E5%B8%9D%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2165]Median Pyramid Hard]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2165-Median-Pyramid-Hard%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2163]Median Pyramid Easy]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2163-Median-Pyramid-Easy%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2557]Ball Coloring]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2557-Ball-Coloring%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2567]RGB Sequence]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2567-RGB-Sequence%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2002]营业额统计]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2002-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2369]Ants on a Circle]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2369-Ants-on-a-Circle%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2017]礼物]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2017-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu1361]小M的作物]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu1361-%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2012]灾难]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2012-%E7%81%BE%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[$ZJOI$里面的小清新思维题，思路参考了一些大神的博客 首先每个节点死亡的条件就是指向它的所有食物都已经死亡 那么我们可以反向建图，每个点指向它的食物 既然保证这个图没有环，那么我们显然可以拓扑排序 然后我们继续思考，不难发现每个节点死亡的条件等价于它所有食物的$LCA$死亡 因为它所有食物的$LCA$已经死亡，所以它的所有食物也都会死亡 最后求一下所有子树大小的前缀和就行，这里记得要减去自身 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,sum,num1,num2;int to1[400004],to2[400004];int from1[400004],from2[400004];int head1[400004],head2[400004];int ans[100001],ind[100001],topo[100001];int f[100001][18],depth[100001],father[100001];inline void add1(int from,int to) &#123; from1[++num1]=head1[from]; to1[num1]=to; head1[from]=num1;&#125;inline void add2(int from,int to) &#123; from2[++num2]=head2[from]; to2[num2]=to; head2[from]=num2;&#125;inline int LCA(int x,int y) &#123; if(depth[x]&lt;depth[y]) swap(x,y); for(register int i=16;i&gt;=0;--i) if(f[x][i]!=0&amp;&amp;depth[f[x][i]]&gt;=depth[y]) x=f[x][i]; if(x==y) return y; for(register int i=16;i&gt;=0;--i) if(f[x][i]!=0&amp;&amp;f[y][i]!=0&amp;&amp;f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return father[x];&#125;inline void RMQ(int x) &#123; f[x][0]=father[x]; for(register int i=1;i&lt;=16;++i) f[x][i]=f[f[x][i-1]][i-1];&#125;inline void Build() &#123; depth[n+1]=1,father[n+1]=n+1; for(register int i=n;i;--i) &#123; int x=topo[i]; if(!head1[x]) &#123; add2(n+1,x),depth[x]=2; f[x][0]=n+1,father[x]=n+1; continue ; &#125; int lca=to1[head1[x]]; for(register int i=from1[head1[x]];i;i=from1[i]) lca=LCA(lca,to1[i]); depth[x]=depth[lca]+1,father[x]=lca; add2(lca,x),RMQ(x); &#125;&#125;inline void DPtree(int x) &#123; ans[x]=1; for(register int i=head2[x];i;i=from2[i]) DPtree(to2[i]),ans[x]+=ans[to2[i]];&#125;inline void Toposort() &#123; queue &lt; int &gt; Q; for(register int i=1;i&lt;=n;++i) if(!ind[i]) Q.push(i); while(!Q.empty()) &#123; int x=Q.front(); Q.pop(); topo[++sum]=x; for(register int i=head1[x];i;i=from1[i]) &#123; --ind[to1[i]]; if(!ind[to1[i]]) Q.push(to1[i]); &#125; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; while(true) &#123; scanf("%d",&amp;m); if(!m) break ; else add1(i,m),++ind[m]; &#125; &#125; Toposort(); Build(); DPtree(n+1); for(register int i=1;i&lt;=n;++i) printf("%d\n",ans[i]-1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SHOI2011]双倍回文]]></title>
    <url>%2F2019%2F03%2F23%2FSHOI2011-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[又是一道回文自动机的好题 如果一个串是双倍回文串，一定满足两个条件 长度是4的倍数 有一个长度为它的长度一半的回文后缀 先预处理建立回文自动机，再枚举每一个节点 暴力跳$fail$指针，判断是否存在长度为它一半的回文后缀即可 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;char s[500005];int fail[500005];int len[500005];int ch[500005][26];int n,ans,tot,last;int main() &#123; scanf("%d%s",&amp;n,s+1); tot=1;fail[0]=1;len[1]=-1; for(register int i=1;i&lt;=n;++i) &#123; while(s[i-len[last]-1]!=s[i]) last=fail[last]; if(!ch[last][s[i]-'a']) &#123; len[++tot]=len[last]+2; int j=fail[last]; while(s[i-len[j]-1]!=s[i]) j=fail[j]; fail[tot]=ch[j][s[i]-'a']; ch[last][s[i]-'a']=tot; &#125; last=ch[last][s[i]-'a']; &#125; for(register int i=tot;i;--i) &#123; int j=i; if(len[i]%4&gt;0||len[i]&lt;=ans) continue ; while((len[j]&lt;&lt;1)&gt;len[i]) j=fail[j]; if(len[j]&lt;&lt;1==len[i]) ans=len[i]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[APIO2014]回文串]]></title>
    <url>%2F2019%2F03%2F23%2FAPIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[因为最近沉迷搞学科所以没有半个月没有更博 毫无疑问这题最简单的做法应该是回文自动机 暴力跳$fail$指针再顺便统计一下节点的个数 最后取最大值即可，就是一道$PAM$模板题 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;char s[300003];int n,tot,last;int cnt[300003];int len[300003];int fail[300003];int ch[300003][26];long long ans;int main() &#123; scanf("%s",s+1);n=strlen(s+1); tot=1;fail[0]=1;len[1]=-1; for(register int i=1;i&lt;=n;++i) &#123; while(s[i-len[last]-1]!=s[i]) last=fail[last]; if(!ch[last][s[i]-'a']) &#123; len[++tot]=len[last]+2; int j=fail[last]; while(s[i-len[j]-1]!=s[i]) j=fail[j]; fail[tot]=ch[j][s[i]-'a']; ch[last][s[i]-'a']=tot; &#125; last=ch[last][s[i]-'a']; ++cnt[last]; &#125; for(register int i=tot;i&gt;=2;--i) &#123; cnt[fail[i]]+=cnt[i]; ans=max(ans,(long long)len[i]*(long long)cnt[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CTSC2014]企鹅QQ]]></title>
    <url>%2F2019%2F02%2F26%2FCTSC2014-%E4%BC%81%E9%B9%85QQ%2F</url>
    <content type="text"><![CDATA[这道题是一道哈希的裸题 其实学长之前上课讲哈希的时候顺带讲过 只是当时我在干嘛？？？ 先把所有字符串的哈希值都预处理出来 然后枚举哪一位不一样 把所有字符串这一位前缀和后缀的哈希值加起来 最后判断刚才计算的哈希值是否相等并且统计答案即可 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int l,m,n,ans,now;char s[202];unsigned long long t[30003];unsigned long long _hash[30003][202];unsigned long long hash_[30003][202];int main()&#123; scanf("%d%d%d",&amp;n,&amp;l,&amp;m); for(register int i=1;i&lt;=n;++i) &#123; scanf("%s",s+1); for(register int j=1;j&lt;=l;++j) _hash[i][j]=_hash[i][j-1]*223+s[j]; for(register int j=l;j&gt;=1;--j) hash_[i][j]=hash_[i][j+1]*233+s[j]; &#125; for(register int i=1;i&lt;=l;++i) &#123; for(register int j=1;j&lt;=n;++j) t[j]=_hash[j][i-1]*229+hash_[j][i+1]*239; sort(t+1,t+n+1);now=1; for(register int j=2;j&lt;=n;++j) t[j-1]==t[j]?ans+=now++:now=1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode873]Length of Longest Fibonacci Subsequence]]></title>
    <url>%2F2019%2F02%2F23%2FLeetCode873-Length-of-Longest-Fibonacci-Subsequence%2F</url>
    <content type="text"><![CDATA[考试的时候这道题直接看错了题意，后来看懂了之后就直接不会做 因为是$Fibonacci$，所以考虑$DP$ 可以设$F$$[$$i$$]$$[$$j$$]$为以$C$$[$$i$$]$为当前数，以$C$$[$$j$$]$为当前倒数第一个数的最大长度 我们可以考虑枚举$i$、$j$、$k$ 如果$C$$[$$i$$]$$=$$C$$[$$j$$]$$+$$C$$[$$k$$]$ 那么转移合法，$F$$[$$i$$]$$[$$j$$]$$=$$max$$($$F$$[$$i$$]$$[$$j$$]$$,$$F$$[$$j$$]$$[$$k$$]$$+$$1$$)$ 但是这样的复杂度就是$O$$($$n^3$$)$的，那么考虑优化 如果枚举$i$、$j$，那么$C$$[$$k$$]$$=$$C$$[$$i$$]$$-$$C$$[$$j$$]$是固定的 这里可以离散化和二分查找，时间复杂度是$log$级别的 然后再用$G$$[$$j$$]$$[$$i$$]$表示对于$C$$[$$k$$]$的最大值即可 那么总时间复杂度就是$O$$($$n^2$$logn$$)$的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,ans;int a[3333];int b[3333];int c[3333];int f[3333][3333];int g[3333][3333];inline int read()&#123; char ch=getchar();int c=0,f=1; while(!isdigit(ch)) &#123; if(ch=='-') f=0; ch=getchar(); &#125; while(isdigit(ch)) c=(c&lt;&lt;3)+(c&lt;&lt;1)+(ch^'0'),ch=getchar(); return f?c:-c;&#125;inline int Half(int z)&#123; int l=1,r=m,mid; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(a[mid]&gt;z) r=mid-1; else if(a[mid]&lt;z) l=mid+1; else return mid; &#125; return 0;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;++i) c[i]=read(),b[i]=c[i]; sort(b+1,b+n+1);a[++m]=b[1]; for(register int i=2;i&lt;=n;++i) &#123; if(b[i-1]==b[i]) continue ; a[++m]=b[i]; &#125; for(register int i=2;i&lt;=n;++i) for(register int j=1;j&lt;i;++j) &#123; f[j][i]=2; int k=Half(c[i]-c[j]); int l=Half(c[j]); f[j][i]=max(f[j][i],g[k][j]+1); ans=max(ans,f[j][i]); g[l][i]=max(g[l][i],f[j][i]); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>离散化</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU5763]Another Meaning]]></title>
    <url>%2F2019%2F02%2F23%2FHDU5763-Another-Meaning%2F</url>
    <content type="text"><![CDATA[话说这道题考场上把我弄自闭了 $KMP$板子有点忘记了，强行回忆了一波 然后突然发现不会计数。。。 不会$DP$的我就自闭了，其实这题$DP$式子不是一般的简单 先把子串的$Fail$指针预处理出来 然后在母串中匹配出子串的位置 最后进行$DP$计数，转移方程$F$$[$$i$$]$$=$$F$$[$$i-1$$]$$+$$F$$[$$i-m$$]$ 其中$i$是母串中成功匹配的位置，$m$为子串的长度 因为每匹配一次子串，都会带来新的意思，加上这个子串的方案数即可 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;char s[200002];char t[200002];int m,n,T;int f[200002];int fail[200002];int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",s+1,t+1); n=strlen(s+1);m=strlen(t+1); for(register int i=2;i&lt;=m;++i) &#123; int j=fail[i-1]; while(j&amp;&amp;t[j+1]!=t[i]) j=fail[j]; if(t[j+1]==t[i]) ++j; fail[i]=j; &#125; f[0]=1; for(register int i=1,j=0;i&lt;=n;++i) &#123; while(j&amp;&amp;s[i]!=t[j+1]) j=fail[j]; if(s[i]==t[j+1]) ++j; if(j==m) j=fail[j],f[i]=f[i-m]; f[i]+=f[i-1]; f[i]-=f[i]&gt;=mod?mod:0; &#125; printf("%d\n",f[n]); memset(f,0,sizeof(f)); memset(fail,0,sizeof(fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[IOI2000]回文字串]]></title>
    <url>%2F2019%2F02%2F23%2FIOI2000-%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[今天模拟赛三道动态规划，这是最简单的一道 考试的时候想的是贪心，大力分类讨论一波以为能过 考完才知道正解就是一道最长公共子序列？？？ 这个跟回文串的性质有关，它正着读和倒着读是完全一样的 这样的话我们就可以把原串反过来跟它自己匹配 最后的答案就是原串的长度减去匹配的长度 考完才发现我不会打最长公共子序列 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;char s1[10086];char s2[10086];int f[5005][5005];int n,ans;int main()&#123; scanf("%s",s1+1);n=strlen(s1+1); for(register int i=1;i&lt;=n;++i) s2[n-i+1]=s1[i]; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(s1[i]==s2[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); ans=n-f[n][n]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
