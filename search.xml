<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2019%2F04%2F05%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[明天就是省选，现在还在颓颓颓，珍惜最后的欢乐时光 颓到一半心情突然有些烦，开始搬博客 看着自己以前的博客有种啼笑皆非的感觉？？？ $Day0$ 前一天晚上教练就作了安排，上午自习下午放假 不错不错，还算有点人性 一想起别人在考期中而我们在放假，还是比较开心的 上午主要就是看一看考试注意事项，$5$分钟就看完了 机房里面一堆人在打板子，看着就烦。。。 旁边$ZCY$喊我打$Slay$，人生第一次打$Slay$ 反正马上就考试了，也不在乎这些了 大考大玩，小考小玩 然后就这么颓废了一上午 中午我爸突然就过来了？？？ 本来下午还想出去玩的 在租的房子里睡了一个下午，现在睡觉都是一种奢侈 醒来之后突发奇想，从城北$CSYZ$跑到城南$MDZX$，去找$JZH$ 请$JZH$在外面吃了饭，再送他回学校上晚自习 $JZH$还是一点也没没变，好兄弟一辈子 然后突然想回学校机房，之后又是和$ZCY$的$Slay$大战 老妈晚上也过来了，回家倒头就睡 真TM颓废的一天，连自己都有点看不下去。。。 $Day1$ 起得特别早，到学校门口集合统一坐车前往$CSLG$ 老习惯又是一罐雀巢特浓顶着 上了车就开始奶人，旁边的$WTH$一度被我奶到怀疑人生 提前$20$分钟进了考场，第一次$NOIP$还是有点紧张的 监考老师提前$10$分钟给出了解压密码，然后我就解压开始写 $T1$一道普及-的题，竟然没有推出正解,最后选择了打暴力 而且暴力很玄学，复杂度$O(ansn2)$ 这可能跟我的考试习惯有关系，总是懒得去推正解 最后总是不能A题，这一次终于吃到苦头了 $T2$我看题用了很久，最后还是正确理解了题意 但是我竟然没去想背包，我的第一反应竟然是暴搜。。。 这就很无语了，还好我还加了一点点剪枝 $T3$我看到题的时候是有点懵的，看了很久还是没有完全看懂 抱着骗分的心态，我试着去打了一个暴力 直到现在我都不知道我当时怎么想的，也不清楚当时是怎么打完的 记忆很模糊了，只是感觉程序长得有点像$Dijkstra$。。。 出了考场我就知道自己凉了，旁边一群大佬说什么今天大众分$255$ 全程低级暴力的我只有$80+70+5=155$ 下午又是睡一下午，晚上又去机房颓废一晚上 $Day2$ 路上不想奶人了，也没有那个心情 满脑子想的都是今天怎么翻盘 今天没有提前发解压密码，而且草稿纸一人只有一张，全程差评 $T1$我又是用了一个暴搜去实现了$n-1$条边的情况， 但是没有想到$n$条边的情况就是暴力拆边。。。 $T2$我推了差不多两个小时，草稿纸早就没了 拿着一包纸巾打草稿可还行 差不多写完小半包纸巾，我感觉自己推出了一个$Fibonacci$。。。 当时也没仔细想就打了上去 $T3$贪心暴力好像过了大样例，最后竟然爆$0$了 总的来说发挥还算好，$T2$乱推式子竟然没萎，总分$60+50+0=110$ 两天总分$155+110=265$,可能要$AFO$？？ 下午去了趟$IFS$，记得上次来到这里还是中考结束 现在一转眼就半年了，半年的$OI$似乎很短暂，可能缘分也就到这里吧 考完强制滚粗补文化课，补到我都有点厌学 很多人$AFO$了,里面就有喊我颓$Slay$的$ZCY$ 我却踩线苟活下来了，那一刻心中真的是百感交集 他们天赋不比我差，也未必见得没我努力 那么能留下来的为什么就是我呢？我不知道 苟活者在淡红的血色中 会依稀看见微茫的希望 谨以此段缅怀那段一起为$NOIP2018$奋斗的岁月]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2006]超级英雄]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2006-%E8%B6%85%E7%BA%A7%E8%8B%B1%E9%9B%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3809]后缀排序]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3809-%E5%90%8E%E7%BC%80%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]最长双回文串]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3805]Manacher算法]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3805-Manacher%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2008]树的统计]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3796]AC自动机（加强版）]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3796-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3808]AC自动机（简单版）]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3808-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2014]力]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2014-%E5%8A%9B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3807]卢卡斯定理]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3807-%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu4139]上帝和集合的正确用法]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu4139-%E4%B8%8A%E5%B8%9D%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu4781]拉格朗日插值]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu4781-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2165]Median Pyramid Hard]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2165-Median-Pyramid-Hard%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2163]Median Pyramid Easy]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2163-Median-Pyramid-Easy%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2557]Ball Coloring]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2557-Ball-Coloring%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2567]RGB Sequence]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2567-RGB-Sequence%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2002]营业额统计]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2002-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2369]Ants on a Circle]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2369-Ants-on-a-Circle%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2017]礼物]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2017-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3391]文艺平衡树]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3391-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3369]普通平衡树]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3369-%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3083]多项式乘法（FFT）]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3083-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95%EF%BC%88FFT%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu1361]小M的作物]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu1361-%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3386]二分图匹配]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3386-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3376]网络最大流]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu3376-%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2012]灾难]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2012-%E7%81%BE%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[$ZJOI$里面的小清新思维题，思路参考了一些大神的博客 首先每个节点死亡的条件就是指向它的所有食物都已经死亡 那么我们可以反向建图，每个点指向它的食物 既然保证这个图没有环，那么我们显然可以拓扑排序 然后我们继续思考，不难发现每个节点死亡的条件等价于它所有食物的$LCA$死亡 因为它所有食物的$LCA$已经死亡，所以它的所有食物也都会死亡 最后求一下所有子树大小的前缀和就行，这里记得要减去自身 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,sum,num1,num2;int to1[400004],to2[400004];int from1[400004],from2[400004];int head1[400004],head2[400004];int ans[100001],ind[100001],topo[100001];int f[100001][18],depth[100001],father[100001];inline void add1(int from,int to) &#123; from1[++num1]=head1[from]; to1[num1]=to; head1[from]=num1;&#125;inline void add2(int from,int to) &#123; from2[++num2]=head2[from]; to2[num2]=to; head2[from]=num2;&#125;inline int LCA(int x,int y) &#123; if(depth[x]&lt;depth[y]) swap(x,y); for(register int i=16;i&gt;=0;--i) if(f[x][i]!=0&amp;&amp;depth[f[x][i]]&gt;=depth[y]) x=f[x][i]; if(x==y) return y; for(register int i=16;i&gt;=0;--i) if(f[x][i]!=0&amp;&amp;f[y][i]!=0&amp;&amp;f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return father[x];&#125;inline void RMQ(int x) &#123; f[x][0]=father[x]; for(register int i=1;i&lt;=16;++i) f[x][i]=f[f[x][i-1]][i-1];&#125;inline void Build() &#123; depth[n+1]=1,father[n+1]=n+1; for(register int i=n;i;--i) &#123; int x=topo[i]; if(!head1[x]) &#123; add2(n+1,x),depth[x]=2; f[x][0]=n+1,father[x]=n+1; continue ; &#125; int lca=to1[head1[x]]; for(register int i=from1[head1[x]];i;i=from1[i]) lca=LCA(lca,to1[i]); depth[x]=depth[lca]+1,father[x]=lca; add2(lca,x),RMQ(x); &#125;&#125;inline void DPtree(int x) &#123; ans[x]=1; for(register int i=head2[x];i;i=from2[i]) DPtree(to2[i]),ans[x]+=ans[to2[i]];&#125;inline void Toposort() &#123; queue &lt; int &gt; Q; for(register int i=1;i&lt;=n;++i) if(!ind[i]) Q.push(i); while(!Q.empty()) &#123; int x=Q.front(); Q.pop(); topo[++sum]=x; for(register int i=head1[x];i;i=from1[i]) &#123; --ind[to1[i]]; if(!ind[to1[i]]) Q.push(to1[i]); &#125; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; while(true) &#123; scanf("%d",&amp;m); if(!m) break ; else add1(i,m),++ind[m]; &#125; &#125; Toposort(); Build(); DPtree(n+1); for(register int i=1;i&lt;=n;++i) printf("%d\n",ans[i]-1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3384]树链剖分]]></title>
    <url>%2F2019%2F04%2F04%2FLuogu3384-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[在学习树链剖分之前，务必先学习线段树 不然就会像我一样，学了等于没学 这个我会补一篇总结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;int a[2000002];int b[2000002];int fa[2000002];int idx[2000002];int son[2000002];int top[2000002];int tot[2000002];int deep[2000002];int head[2000002];int m,n,r,p,x,y,z,cnt,num,tpe;struct Node &#123; int u,v,next; &#125; edge[2000002];struct Tree &#123; int f,l,r,w,size; &#125; tree[2000002];inline int read()&#123; char ch=getchar();int c=0,f=1; while(!isdigit(ch)) &#123; if(ch=='-') f=0; ch=getchar(); &#125; while(isdigit(ch)) c=(c&lt;&lt;3)+(c&lt;&lt;1)+(ch^'0'),ch=getchar(); return f?c:-c;&#125;inline void update(int k) &#123; tree[k].w=(tree[k&lt;&lt;1].w+tree[k&lt;&lt;1|1].w+p)%p; &#125;inline void add(int u,int v)&#123; edge[++num].u=u; edge[num].v=v; edge[num].next=head[u]; head[u]=num;&#125;inline void build(int k,int l,int r)&#123; tree[k].l=l,tree[k].r=r,tree[k].size=r-l+1; if(l==r) &#123; tree[k].w=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid),build(k&lt;&lt;1|1,mid+1,r);update(k);&#125;inline void Dfs1(int u,int f)&#123; deep[u]=deep[f]+1; fa[u]=f;son[u]=0;tot[u]=1; for(register int i=head[u];i;i=edge[i].next) &#123; if(edge[i].v==f) continue ; Dfs1(edge[i].v,u);tot[u]+=tot[edge[i].v]; if(tot[edge[i].v]&gt;tot[son[u]]) son[u]=edge[i].v; &#125;&#125;inline void Dfs2(int u,int f)&#123; idx[u]=++cnt;a[cnt]=b[u];top[u]=f; if(!son[u]) return ; Dfs2(son[u],f); for(register int i=head[u];i;i=edge[i].next) if(!idx[edge[i].v]) Dfs2(edge[i].v,edge[i].v);&#125;inline void pushdown(int k)&#123; if(!tree[k].f) return ; (tree[k&lt;&lt;1].w+=tree[k&lt;&lt;1].size*tree[k].f)%=p; (tree[k&lt;&lt;1|1].w+=tree[k&lt;&lt;1|1].size*tree[k].f)%=p; (tree[k&lt;&lt;1].f+=tree[k].f)%=p;(tree[k&lt;&lt;1|1].f+=tree[k].f)%=p;tree[k].f=0;&#125;inline void IntervalAdd(int k,int l,int r,int val)&#123; if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r) &#123; tree[k].w+=tree[k].size*val; tree[k].f+=val;return ; &#125; pushdown(k);int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(l&lt;=mid) IntervalAdd(k&lt;&lt;1,l,r,val); if(r&gt;mid) IntervalAdd(k&lt;&lt;1|1,l,r,val); update(k);&#125;inline void TreeAdd(int x,int y,int val)&#123; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); IntervalAdd(1,idx[top[x]],idx[x],val);x=fa[top[x]]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); IntervalAdd(1,idx[x],idx[y],val);&#125;inline int IntervalSum(int k,int l,int r)&#123; int ans=0; if(l&lt;=tree[k].l&amp;&amp;tree[k].r&lt;=r) return tree[k].w; pushdown(k);int mid=(tree[k].l+tree[k].r)&gt;&gt;1; if(l&lt;=mid) (ans+=IntervalSum(k&lt;&lt;1,l,r))%=p; if(r&gt;mid) (ans+=IntervalSum(k&lt;&lt;1|1,l,r))%=p; return ans;&#125;inline void TreeSum(int x,int y)&#123; int ans=0; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); (ans+=IntervalSum(1,idx[top[x]],idx[x]))%=p;x=fa[top[x]]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); (ans+=IntervalSum(1,idx[x],idx[y]))%=p; printf("%d\n",ans);&#125;int main()&#123; n=read(),m=read(),r=read(),p=read(); for(register int i=1;i&lt;=n;++i) b[i]=read(); for(register int i=1;i&lt;=n-1;++i) x=read(),y=read(),add(x,y),add(y,x); Dfs1(r,0);Dfs2(r,r);build(1,1,n); for(register int i=1;i&lt;=m;++i) &#123; tpe=read(); if(tpe==1) x=read(),y=read(),z=read(),TreeAdd(x,y,z%p); else if(tpe==2) x=read(),y=read(),TreeSum(x,y); else if(tpe==3) x=read(),z=read(),IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%p); else x=read(),printf("%d\n",IntervalSum(1,idx[x],idx[x]+tot[x]-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3810]陌上花开]]></title>
    <url>%2F2019%2F03%2F23%2FLuogu3810-%E9%99%8C%E4%B8%8A%E8%8A%B1%E5%BC%80%2F</url>
    <content type="text"><![CDATA[一入压行深似海，从此换行是路人 排序解决第一维 $CDQ$解决第二维 树状数组解决第三维 留坑代填 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,cnt,ans[100001],tree[200002];struct sakura &#123; int a,b,c,ans,sum; &#125; node[100001],now[100001];inline bool cmp1(sakura x,sakura y) &#123; if(x.a!=y.a) return x.a&lt;y.a; else if(x.b!=y.b) return x.b&lt;y.b; else return x.c&lt;y.c;&#125;inline bool cmp2(sakura x,sakura y) &#123; if(x.b!=y.b) return x.b&lt;y.b; else return x.c&lt;y.c;&#125;inline void add(int x,int val) &#123; for(register int i=x;i&lt;=k;i+=(i&amp;-i)) tree[i]+=val;&#125;inline int query(int x) &#123; int num=0; for(register int i=x;i;i-=(i&amp;-i)) num+=tree[i]; return num;&#125;inline void CDQ(int l,int r) &#123; if(l==r) return ; int j=l,mid=(l+r)&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); sort(&amp;now[l],&amp;now[mid+1],cmp2),sort(&amp;now[mid+1],&amp;now[r+1],cmp2); for(register int i=mid+1;i&lt;=r;++i) &#123; while(j&lt;=mid&amp;&amp;now[j].b&lt;=now[i].b) add(now[j].c,now[j].sum),++j; now[i].ans+=query(now[i].c); &#125; for(register int i=l;i&lt;j;++i) add(now[i].c,-now[i].sum);&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;k); for(register int i=1;i&lt;=n;++i) scanf("%d%d%d",&amp;node[i].a,&amp;node[i].b,&amp;node[i].c); sort(node+1,node+n+1,cmp1); for(register int i=1;i&lt;=n;++i) &#123; if(node[i-1].a==node[i].a&amp;&amp;node[i-1].b==node[i].b&amp;&amp;node[i-1].c==node[i].c) ++now[cnt].sum; else ++cnt,now[cnt]=node[i],++now[cnt].sum; &#125; CDQ(1,cnt); for(register int i=1;i&lt;=cnt;++i) ans[now[i].ans+now[i].sum-1]+=now[i].sum; for(register int i=0;i&lt;n;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SHOI2011]双倍回文]]></title>
    <url>%2F2019%2F03%2F23%2FSHOI2011-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[又是一道回文自动机的好题 如果一个串是双倍回文串，一定满足两个条件 长度是4的倍数 有一个长度为它的长度一半的回文后缀 先预处理建立回文自动机，再枚举每一个节点 暴力跳$fail$指针，判断是否存在长度为它一半的回文后缀即可 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;char s[500005];int fail[500005];int len[500005];int ch[500005][26];int n,ans,tot,last;int main() &#123; scanf("%d%s",&amp;n,s+1); tot=1;fail[0]=1;len[1]=-1; for(register int i=1;i&lt;=n;++i) &#123; while(s[i-len[last]-1]!=s[i]) last=fail[last]; if(!ch[last][s[i]-'a']) &#123; len[++tot]=len[last]+2; int j=fail[last]; while(s[i-len[j]-1]!=s[i]) j=fail[j]; fail[tot]=ch[j][s[i]-'a']; ch[last][s[i]-'a']=tot; &#125; last=ch[last][s[i]-'a']; &#125; for(register int i=tot;i;--i) &#123; int j=i; if(len[i]%4&gt;0||len[i]&lt;=ans) continue ; while((len[j]&lt;&lt;1)&gt;len[i]) j=fail[j]; if(len[j]&lt;&lt;1==len[i]) ans=len[i]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[APIO2014]回文串]]></title>
    <url>%2F2019%2F03%2F23%2FAPIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[因为最近沉迷搞学科所以没有半个月没有更博 毫无疑问这题最简单的做法应该是回文自动机 暴力跳$fail$指针再顺便统计一下节点的个数 最后取最大值即可，就是一道$PAM$模板题 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;char s[300003];int n,tot,last;int cnt[300003];int len[300003];int fail[300003];int ch[300003][26];long long ans;int main() &#123; scanf("%s",s+1);n=strlen(s+1); tot=1;fail[0]=1;len[1]=-1; for(register int i=1;i&lt;=n;++i) &#123; while(s[i-len[last]-1]!=s[i]) last=fail[last]; if(!ch[last][s[i]-'a']) &#123; len[++tot]=len[last]+2; int j=fail[last]; while(s[i-len[j]-1]!=s[i]) j=fail[j]; fail[tot]=ch[j][s[i]-'a']; ch[last][s[i]-'a']=tot; &#125; last=ch[last][s[i]-'a']; ++cnt[last]; &#125; for(register int i=tot;i&gt;=2;--i) &#123; cnt[fail[i]]+=cnt[i]; ans=max(ans,(long long)len[i]*(long long)cnt[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu1835]素数密度]]></title>
    <url>%2F2019%2F03%2F09%2FLuogu1835-%E7%B4%A0%E6%95%B0%E5%AF%86%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[今天模拟赛第一题成功劝退 欧拉筛显然是不行的，但是我们要用它来预处理 先用欧拉筛来筛出$O$$($$\sqrt{m}$$)$内的质数 然后用类似埃氏筛的方法，用已经筛出来的质数去再在$($n$ $,$ $m$)$范围内筛 最后还要用$unsigned$卡卡常开开$O2$就过了 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define int unsigned intusing namespace std;int prime[100001];int ovo[100001];int n,m,ans,tot;signed main() &#123; scanf("%d%d",&amp;n,&amp;m); ovo[0]=ovo[1]=1; for(register int i=1;i&lt;=46342;++i) &#123; if(!ovo[i]) prime[++tot]=i; for(register int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;=46342;++j) &#123; ++ovo[i*prime[j]]; if(i%prime[j]==0) break ; &#125; &#125; n=max(n,(int)2); for(register int i=n;i&lt;=m;++i) &#123; for(register int j=1;j&lt;=tot&amp;&amp;prime[j]*prime[j]&lt;=i;++j) if(i%prime[j]==0) &#123; --ans; break ; &#125; ++ans; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>欧拉筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5239]回忆京都]]></title>
    <url>%2F2019%2F03%2F05%2FLuogu5239-%E5%9B%9E%E5%BF%86%E4%BA%AC%E9%83%BD%2F</url>
    <content type="text"><![CDATA[提到组合数就想起杨辉三角 这道题的数据范围显然不能直接搞 我们可以预处理出杨辉三角 从上往下做一遍前缀和 最后只要在一行里面统计答案即可 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;long long m,n,ans,Q;long long f[1008][1008];const long long mod=19260817;int main()&#123; f[1][1]=1; for(register int i=2;i&lt;=1001;++i) for(register int j=1;j&lt;=i;++j) f[i][j]=(f[i-1][j]+f[i-1][j-1])%mod; for(register int i=1;i&lt;=1001;++i) for(register int j=i+1;j&lt;=1001;++j) (f[j][i]+=f[j-1][i])%=mod; scanf("%lld",&amp;Q); while(Q--) &#123; scanf("%lld%lld",&amp;n,&amp;m); ans=0;++m,++n; for(register int i=2;i&lt;=n;++i) (ans+=f[m][i])%=mod; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu5238]整数校验器]]></title>
    <url>%2F2019%2F03%2F05%2FLuogu5238-%E6%95%B4%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%99%A8%2F</url>
    <content type="text"><![CDATA[把洛谷月赛当$ACM$打差点出惨案 就是这道题导致开黑被发现。。。 开始是自己码的，码了半个小时结果全$WA$ 然后大力调调调，调了半个小时结果还是全$WA$ 然后拿着$Jerry$的代码魔改之后就交了，可能魔改得不彻底吧 言归正传，这道题严格意义上来说应该算一道大模拟 需要判断的情况特别多，还有这种一个负号的 总之大力分类讨论几波即可，下面贴代码 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;char s[1000001];long long m,n,l,r,T;unsigned long long num;int main()&#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;T); while(T--) &#123; scanf("%s",s+1); n=strlen(s+1);num=0; if(s[1]=='-'&amp;&amp;(n==1||s[2]=='0'))&#123; puts("1"); continue ; &#125; if(s[1]=='0'&amp;&amp;n!=1) &#123; puts("1"); continue ; &#125; if(s[1]!='-'&amp;&amp;n&gt;19) &#123; puts("2"); continue ; &#125; if(s[1]=='-'&amp;&amp;n&gt;20) &#123; puts("2"); continue ; &#125; if(s[1]!='-') &#123; for(register long long i=1;i&lt;=n;++i) num=num*10+s[i]-'0'; if(num&gt;=(unsigned long long)1&lt;&lt;63) &#123; puts("2"); continue ; &#125; m=num; &#125; if(s[1]=='-') &#123; for(register long long i=2;i&lt;=n;++i) num=num*10+s[i]-'0'; if(num&gt;(unsigned long long)1&lt;&lt;63) &#123; puts("2"); continue ; &#125; m=-num; &#125; puts(l&lt;=m&amp;&amp;m&lt;=r?"0":"2"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3375]KMP字符串匹配]]></title>
    <url>%2F2019%2F02%2F27%2FLuogu3375-KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[因为是模板题所以就只贴代码 学习笔记戳这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;char s1[1000001];char s2[1000001];int m,n,tot;int ans[1000001];int next[1000001];inline void P()&#123; next[0]=-1; for(register int i=1;i&lt;m;++i) &#123; int j=next[i-1]; while(j&gt;=0&amp;&amp;s2[j+1]!=s2[i]) j=next[j]; if(s2[j+1]==s2[i]) next[i]=j+1; else next[i]=-1; &#125;&#125;inline void KMP()&#123; int i=0,j=0; while(i&lt;n) &#123; if(s1[i]==s2[j]) &#123; ++i;++j; if(j==m) &#123; ans[++tot]=i-m+1; j=next[j-1]+1; &#125; &#125; else &#123; if(j==0) ++i; else j=next[j-1]+1; &#125; &#125;&#125;int main()&#123; scanf("%s%s",s1,s2); n=strlen(s1);m=strlen(s2); P();KMP(); for(register int i=1;i&lt;=tot;++i) printf("%d\n",ans[i]); for(register int i=0;i&lt;m;++i) printf("%d ",next[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈KMP]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%B5%85%E8%B0%88KMP%2F</url>
    <content type="text"><![CDATA[$KMP$算法是一种很基本的字符串匹配算法 $KMP$算法通常用来解决在母串中寻找子串的问题 但是$KMP$算法不太容易理解，我觉得我是不可能讲清楚的 $KMP$算法最难的地方就是失配指针，也就是$Next$数组 如果是普通的一位一位去匹配的话，会匹配许多无效信息 那么我们可以考虑利用已知信息，构建一个失配指针来解决这个问题 失配指针的作用就是在每次匹配失败的时候 直接跳转到下一个有效信息进行匹配，避免时间的浪费 失配指针的构建跟当前成功匹配串的最长相同前后缀有关 因为最长相同前后缀一定是相同的 那么如果当前这一位匹配失败，那么我们可以将整个串跳转到后缀上再重新开始匹配 这就是$KMP$算法的思想，是不是感觉特别简单？？？ 至于我们怎么预处理计算$Next$数组，就是用子串匹配子串 这里要结合代码讲一下，码风有点小众先注明一下 所有字符串从$0$开始，$Next$数组的初始值为$-1$，那么真实值就要$+1$ 1234567for (register int i=1;i&lt;n;++i)&#123; int j=Next[i-1]; while (S[i]!=S[j+1]&amp;&amp;j&gt;=0) j=F[j]; if (B[j+1]==B[i]) Next[i]=j+1; else Next[i]=-1;&#125; 因为这个是一个线性的递推，所以可以一直往前找到一个最大的相同前后缀为止 如果还没有看懂的话可以自己手玩几组样例，感觉其实我并没有讲清楚 最后安利一下$SYC$大佬的博客]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CTSC2014]企鹅QQ]]></title>
    <url>%2F2019%2F02%2F26%2FCTSC2014-%E4%BC%81%E9%B9%85QQ%2F</url>
    <content type="text"><![CDATA[这道题是一道哈希的裸题 其实学长之前上课讲哈希的时候顺带讲过 只是当时我在干嘛？？？ 先把所有字符串的哈希值都预处理出来 然后枚举哪一位不一样 把所有字符串这一位前缀和后缀的哈希值加起来 最后判断刚才计算的哈希值是否相等并且统计答案即可 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int l,m,n,ans,now;char s[202];unsigned long long t[30003];unsigned long long _hash[30003][202];unsigned long long hash_[30003][202];int main()&#123; scanf("%d%d%d",&amp;n,&amp;l,&amp;m); for(register int i=1;i&lt;=n;++i) &#123; scanf("%s",s+1); for(register int j=1;j&lt;=l;++j) _hash[i][j]=_hash[i][j-1]*223+s[j]; for(register int j=l;j&gt;=1;--j) hash_[i][j]=hash_[i][j+1]*233+s[j]; &#125; for(register int i=1;i&lt;=l;++i) &#123; for(register int j=1;j&lt;=n;++j) t[j]=_hash[j][i-1]*229+hash_[j][i+1]*239; sort(t+1,t+n+1);now=1; for(register int j=2;j&lt;=n;++j) t[j-1]==t[j]?ans+=now++:now=1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3370]字符串哈希]]></title>
    <url>%2F2019%2F02%2F25%2FLuogu3370-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[因为是模板题所以就只贴代码 学习笔记戳这里 这份远古代码貌似还是当时$JBY$大佬边教我边打的 可惜$JBY$大佬退役太早，而且也身不由己 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define moa 19260817#define mob 19491001using namespace std;char s[2002];int m,n,ans;struct AG&#123; int a; int b;&#125;f[10001];inline bool cmp(AG xx,AG yy)&#123; if(xx.a==yy.a) return xx.b&lt;yy.b; return xx.a&lt;yy.a;&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; scanf("%s",s+1); m=strlen(s+1); for(register int j=1;j&lt;=m;++j) &#123; f[i].a=(f[i].a*11+(int)s[j])%moa; f[i].b=(f[i].b*13+(int)s[j])%mob; &#125; &#125; sort(f+1,f+n+1,cmp); ans=1; for(register int i=2;i&lt;=n;++i) if(f[i].a!=f[i-1].a||f[i].b!=f[i-1].b) ++ans; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串哈希]]></title>
    <url>%2F2019%2F02%2F25%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[字符串哈希是一种对于字符串问题的乱搞骗分方法 很多字符串问题都能用哈希得到很高的部分分，所以可以把哈希当暴力打 个人理解，哈希就是把所有字符当做数字来计算 这里的进制最好取一个小一点的质数 就算不取质数也一定要和后面的模数互质 不然的话哈希冲突的概率会成倍增加 如果这个字符串很长的话，计算出来的数字明显是存不下的 所以我们可以通过取模，将这个数字映射到我们能够存下的范围内 既然是映射就会存在冲突，即两个不同的串对应两个不同的数对应两个相同的映射 为了减小哈希冲突的概率，模数我们一般要取一个大一点的质数 当然还是有很多毒瘤出题人专门制造哈希冲突 虽然可能会被卡，但是我们还是有两种方法来解决的 自然溢出 通过不取模让它自然溢出，实际上就是把模数变得很大 然后再用一些奇技淫巧来判断值是否相同，比如$Trie$树 双模数哈希 就是做两遍哈希，只有两个值都完全相等的时候才能通过 至于用如何哈希解决其他的一些字符串问题，先挖个坑在这里以后有时间再慢慢填 谨以此文纪念当初退役前三天教会我哈希的$JBY$大佬]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode873]Length of Longest Fibonacci Subsequence]]></title>
    <url>%2F2019%2F02%2F23%2FLeetCode873-Length-of-Longest-Fibonacci-Subsequence%2F</url>
    <content type="text"><![CDATA[考试的时候这道题直接看错了题意，后来看懂了之后就直接不会做 因为是$Fibonacci$，所以考虑$DP$ 可以设$F$$[$$i$$]$$[$$j$$]$为以$C$$[$$i$$]$为当前数，以$C$$[$$j$$]$为当前倒数第一个数的最大长度 我们可以考虑枚举$i$、$j$、$k$ 如果$C$$[$$i$$]$$=$$C$$[$$j$$]$$+$$C$$[$$k$$]$ 那么转移合法，$F$$[$$i$$]$$[$$j$$]$$=$$max$$($$F$$[$$i$$]$$[$$j$$]$$,$$F$$[$$j$$]$$[$$k$$]$$+$$1$$)$ 但是这样的复杂度就是$O$$($$n^3$$)$的，那么考虑优化 如果枚举$i$、$j$，那么$C$$[$$k$$]$$=$$C$$[$$i$$]$$-$$C$$[$$j$$]$是固定的 这里可以离散化和二分查找，时间复杂度是$log$级别的 然后再用$G$$[$$j$$]$$[$$i$$]$表示对于$C$$[$$k$$]$的最大值即可 那么总时间复杂度就是$O$$($$n^2$$logn$$)$的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,ans;int a[3333];int b[3333];int c[3333];int f[3333][3333];int g[3333][3333];inline int read()&#123; char ch=getchar();int c=0,f=1; while(!isdigit(ch)) &#123; if(ch=='-') f=0; ch=getchar(); &#125; while(isdigit(ch)) c=(c&lt;&lt;3)+(c&lt;&lt;1)+(ch^'0'),ch=getchar(); return f?c:-c;&#125;inline int Half(int z)&#123; int l=1,r=m,mid; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(a[mid]&gt;z) r=mid-1; else if(a[mid]&lt;z) l=mid+1; else return mid; &#125; return 0;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;++i) c[i]=read(),b[i]=c[i]; sort(b+1,b+n+1);a[++m]=b[1]; for(register int i=2;i&lt;=n;++i) &#123; if(b[i-1]==b[i]) continue ; a[++m]=b[i]; &#125; for(register int i=2;i&lt;=n;++i) for(register int j=1;j&lt;i;++j) &#123; f[j][i]=2; int k=Half(c[i]-c[j]); int l=Half(c[j]); f[j][i]=max(f[j][i],g[k][j]+1); ans=max(ans,f[j][i]); g[l][i]=max(g[l][i],f[j][i]); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>离散化</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU5763]Another Meaning]]></title>
    <url>%2F2019%2F02%2F23%2FHDU5763-Another-Meaning%2F</url>
    <content type="text"><![CDATA[话说这道题考场上把我弄自闭了 $KMP$板子有点忘记了，强行回忆了一波 然后突然发现不会计数。。。 不会$DP$的我就自闭了，其实这题$DP$式子不是一般的简单 先把子串的$Fail$指针预处理出来 然后在母串中匹配出子串的位置 最后进行$DP$计数，转移方程$F$$[$$i$$]$$=$$F$$[$$i-1$$]$$+$$F$$[$$i-m$$]$ 其中$i$是母串中成功匹配的位置，$m$为子串的长度 因为每匹配一次子串，都会带来新的意思，加上这个子串的方案数即可 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;char s[200002];char t[200002];int m,n,T;int f[200002];int fail[200002];int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",s+1,t+1); n=strlen(s+1);m=strlen(t+1); for(register int i=2;i&lt;=m;++i) &#123; int j=fail[i-1]; while(j&amp;&amp;t[j+1]!=t[i]) j=fail[j]; if(t[j+1]==t[i]) ++j; fail[i]=j; &#125; f[0]=1; for(register int i=1,j=0;i&lt;=n;++i) &#123; while(j&amp;&amp;s[i]!=t[j+1]) j=fail[j]; if(s[i]==t[j+1]) ++j; if(j==m) j=fail[j],f[i]=f[i-m]; f[i]+=f[i-1]; f[i]-=f[i]&gt;=mod?mod:0; &#125; printf("%d\n",f[n]); memset(f,0,sizeof(f)); memset(fail,0,sizeof(fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[IOI2000]回文字串]]></title>
    <url>%2F2019%2F02%2F23%2FIOI2000-%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[今天模拟赛三道动态规划，这是最简单的一道 考试的时候想的是贪心，大力分类讨论一波以为能过 考完才知道正解就是一道最长公共子序列？？？ 这个跟回文串的性质有关，它正着读和倒着读是完全一样的 这样的话我们就可以把原串反过来跟它自己匹配 最后的答案就是原串的长度减去匹配的长度 考完才发现我不会打最长公共子序列 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;char s1[10086];char s2[10086];int f[5005][5005];int n,ans;int main()&#123; scanf("%s",s1+1);n=strlen(s1+1); for(register int i=1;i&lt;=n;++i) s2[n-i+1]=s1[i]; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(s1[i]==s2[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); ans=n-f[n][n]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3378]堆]]></title>
    <url>%2F2019%2F02%2F22%2FLuogu3378-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[因为是模板题所以就只贴代码 学习笔记戳这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int heap[1000001];int m,n,x,size;inline void put(int y)&#123; int now,next; heap[++size]=y; now=size; while(now&gt;1) &#123; next=now&gt;&gt;1; if(heap[now]&gt;=heap[next]) break; swap(heap[now],heap[next]); now=next; &#125;&#125;inline void get()&#123; int now,next; heap[1]=heap[size--]; now=1; while(now*2&lt;=size) &#123; next=now*2; if(next&lt;size&amp;&amp;heap[next+1]&lt;heap[next]) next++; if(heap[now]&lt;=heap[next]) break; swap(heap[now],heap[next]); now=next; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;m); if(m==1) &#123; scanf("%d",&amp;x); put(x); &#125; if(m==2) printf("%d\n",heap[1]); if(m==3) get(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈手打堆]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%B5%85%E8%B0%88%E6%89%8B%E6%89%93%E5%A0%86%2F</url>
    <content type="text"><![CDATA[故事的起因很有趣，还是去年的事了 $Noip2018$之前谢骚说他不会手打堆？？？ 我当时就一句这么简单的东西怎么不会 然后他就因为这个一直膜我到现在 那时候就有了写一写手打堆的念头 只是因为谢骚$Noip2018$混到一等之后功成身退，所以就一直咕到现在 堆，一般指的是小根堆，它是一颗完全二叉树 它满足一个性质，父亲的权值不大于儿子的权值 由于这个性质，树根存的就是最小值 这里我们来看一下堆的两种操作 插入操作 为了保证插入后也是一棵完全二叉树，我们从最下面一层最右边的叶子节点后面插入 如果最下面一层已满，就新增一层再从最左边开始插入 如果这个结点的权值大于它父亲的权值，就进行交换 直到不满足或者已经到根节点就停止，那么插入操作的复杂度就是$logn$的 删除操作 先把根节点与最后一个节点交换，再删除最后一个节点 如果根节点的权值大于它的儿子的权值，就进行交换 这里究竟是左儿子还是右儿子需要分类讨论一下 直到不满足或者已经到最下面一层就停止，那么删除操作的复杂度就是$logn$的 实际上各种操作都是建立在向上向下交换的基础上的 其实学这玩意还不如用$STL$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.3]修理牛棚 Barn Repair]]></title>
    <url>%2F2019%2F02%2F21%2FUSACO1-3-%E4%BF%AE%E7%90%86%E7%89%9B%E6%A3%9A-Barn-Repair%2F</url>
    <content type="text"><![CDATA[代码应该算是比较简练的 首先可以考虑贪心，而且是$O$ $($ $m$ $)$的贪心 然后再来思考一下贪心策略 这道题其实比较适合反向思维，思考难度因人而异 就是先确定一大块板，再去把它分成很多块小板 具体的来说就是从第一个牛棚到最后一个牛棚 因为这段区间的长度是一定的 又因为总共要覆盖$m$块木板,所以中间最多只能有$m$ $-$ $1$块空隙 所以我们只要找出$m$ $-$ $1$块最大的空隙，以确保木板总长度最短 所以我们可以使用两遍快速排序 第一遍排序牛棚，确定区间的长度 第二遍排序空隙，求出最长的$m$ $-$ $1$块空隙 然后依次减去最长的$m$ $-$ $1$块空隙就是所得的答案 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int w[222];int y[222];int c,m,s,ans;int main()&#123; scanf("%d%d%d",&amp;m,&amp;s,&amp;c); for(register int i=1;i&lt;=c;++i) scanf("%d",&amp;w[i]); if(m&gt;=c) ans=c; else &#123; sort(w+1,w+c+1); ans=w[c]-w[1]+1; for(register int i=1;i&lt;=c-1;++i) y[i]=w[i+1]-w[i]-1; sort(y+1,y+c); for(register int i=c-1;i&gt;=c-m+1;--i) ans-=y[i]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.2]命名那个数字 Name That Number]]></title>
    <url>%2F2019%2F02%2F21%2FUSACO1-2-%E5%91%BD%E5%90%8D%E9%82%A3%E4%B8%AA%E6%95%B0%E5%AD%97-Name-That-Number%2F</url>
    <content type="text"><![CDATA[这道题好像$AC$人数有点少啊 严格意义上来说，这道题是一道水题 就是把名字库转换成数字库，然后暴力匹配即可 但是我同桌提出了一种神奇的暴力 可以很好的锻炼码力，但是可能对新人不太友好 那么的话身为他同桌的我还是帮他填这个坑 跟其他玄学做法相比，其实思维难度真心不大 首先，我们可以先将数字转换成可以用的名字 然后用这些名字去可以选用的名字中匹配 然而这样的最坏复杂度是多少？？？ 卧槽竟然是一个常数。。。 怎么都感觉过不了，然而好像真的有人卡过去了。。。 不知道是数据太水还是$ta$太强了 所以显然是不能暴力匹配的，所以我们可以考虑二分 二分查找来缩小范围，然后就只需要匹配一个 二分的条件就是字典序匹配，从小到大 然而怎么最坏复杂度还是不对？？？ 不管了反正这题数据水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;char name[5005][15];char k[15];char s[15];bool flag;int m,n;char num[11][4]=&#123;&#123;&#125;,&#123;&#125;,&#123;'A','B','C'&#125;,&#123;'D','E','F'&#125;,&#123;'G','H','I'&#125;,&#123;'J','K','L'&#125;,&#123;'M','N','O'&#125;,&#123;'P','R','S'&#125;,&#123;'T','U','V'&#125;,&#123;'W','X','Y'&#125;&#125;;inline void Half()&#123; int l=1,r=4618,mid; while(l&lt;=r) &#123; mid=(l+r)/2; int lon=strlen(name[mid]); flag=true; for(register int i=0;i&lt;n||i&lt;lon;++i) &#123; if(name[mid][i]&lt;k[i]) &#123; l=mid+1; flag=false; break; &#125; if(name[mid][i]&gt;k[i]) &#123; r=mid-1; flag=false; break; &#125; &#125; if(flag) break; &#125; if(strlen(name[mid])!=n) return ; for(register int i=0;i&lt;n;++i) if(name[mid][i]!=k[i]) return ; printf("%s\n",k); ++m;&#125;inline void Dfs(int z)&#123; if(z==n) &#123; Half(); return ; &#125; else &#123; int now=s[z]-'0'; for(register int i=0;i&lt;=2;++i) &#123; k[z]=num[now][i]; Dfs(z+1); &#125; &#125;&#125;int main()&#123; scanf("%s",s); for(register int i=1;i&lt;=4617;++i) scanf("%s",name[i]); n=strlen(s); Dfs(0); if(m==0) puts("NONE"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.2]方块转换 Transformations]]></title>
    <url>%2F2019%2F02%2F19%2FUSACO1-2-%E6%96%B9%E5%9D%97%E8%BD%AC%E6%8D%A2-Transformations%2F</url>
    <content type="text"><![CDATA[一道大模拟又被我打出了160行 还好一次A掉不至于当场去世 毫无技术含量可言 只要基本懂字符串就行 首先，翻转$90$、$180$、$270$其实等于一个操作 就是写一个翻转$90$函数用三遍而已 翻转转移方程可以手玩一下 就是$s$[$i$] [$j$]=s[$n$-$j$+$1$][$i$]，还是比较好推的 然后写一次对称过来，再用三次翻转$90$函数 最后再看是不是和初始状态相同 建议每变化一次就去验证一次 如果成功就直接$return$ $0$，简单粗暴 下面一些题外话 大家做这种题一定要细心 哪怕你压行也要尽量控制代码长度 不然考场上真的很难查错，也很浪费时间 本人天生反面教材 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;using namespace std;char s[11][11];char x[11][11];char y[11][11];char z[11][11];bool flag;int n,ans;inline void C()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) y[i][j]=x[n-j+1][i];&#125;inline void M()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) x[i][j]=y[i][j];&#125;inline void V()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) y[i][j]=x[i][n-j+1];&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; for(register int j=1;j&lt;=n;++j) &#123; cin&gt;&gt;s[i][j]; x[i][j]=s[i][j]; &#125; getchar(); &#125; for(register int i=1;i&lt;=n;++i) &#123; for(register int j=1;j&lt;=n;++j) cin&gt;&gt;z[i][j]; getchar(); &#125; C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("1"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("2"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("3"); return 0; &#125; else &#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) x[i][j]=s[i][j]; &#125; V();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("4"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(s[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) puts("6"); else puts("7"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.1]坏掉的项链Broken Necklace]]></title>
    <url>%2F2019%2F02%2F19%2FUSACO1-1-%E5%9D%8F%E6%8E%89%E7%9A%84%E9%A1%B9%E9%93%BEBroken-Necklace%2F</url>
    <content type="text"><![CDATA[话说$USACO$的水题质量挺高的，好像真的是这样 这道题当时我可是调了一个下午的 这题暴力能过，复杂度就懒得算了 不需要什么思路，直接上模拟 就是枚举断开位置，然后分别往两边找 找到不能再找就停下，看看是否可以更新答案 需要特别提醒的是断开位置两边是$w$的情况 那就需要继续找到第一个不是$w$的位置 用这个位置上的字符去判断 然后就被我硬生生的打出了一道大模拟 别人平均$60$行，我打出了$160$行？？？ 心态崩了，我要妹子 看来我还是太菜了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;char a,b;char s[404];bool t[404];int n,l,r,ans,sum;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) cin&gt;&gt;s[i]; memset(t,false,sizeof(t)); a=s[1];b=s[n]; if(a=='w') &#123; for(register int i=1;i&lt;=n;++i) if(s[i]!='w') &#123; a=s[i]; break; &#125; &#125; if(b=='w') &#123; for(register int i=n;i&gt;=1;--i) if(s[i]!='w') &#123; b=s[i]; break; &#125; &#125; for(register int i=1;i&lt;=n;++i) if(s[i]==a||s[i]=='w') t[i]=true; else break; for(register int i=n;i&gt;=1;--i) if(s[i]==b||s[i]=='w') t[i]=true; else break; for(register int i=1;i&lt;=n;++i) if(t[i]) ++ans; for(register int i=1;i&lt;=n-1;++i) &#123; memset(t,false,sizeof(t)); a=s[i];b=s[i+1];sum=0; if(a=='w') &#123; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; else &#123; for(register int k=n;k&gt;=i+1;--k) if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; &#125; if(b=='w') &#123; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; else &#123; for(register int k=1;k&lt;=i;++k) if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; &#125; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]==a||s[j]=='w') &#123; t[j]=true; for(register int k=n;k&gt;=i+1;--k) if(s[k]==a||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==a||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]==b||s[j]=='w') &#123; t[j]=true; for(register int k=1;k&lt;=i;++k) if(s[k]==b||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==b||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=1;j&lt;=n;++j) if(t[j]) ++sum; ans=max(ans,sum); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
