<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #592 (Div.2)]]></title>
    <url>%2F2019%2F10%2F14%2FCodeforces-Round-592-Div-2%2F</url>
    <content type="text"><![CDATA[纪念一下人生首次$CF$翻车（雾 $A$ 判断是否$\lceil \frac{a}{c}\rceil+\lceil\frac{b}{d}\rceil\leq k$即可 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main () &#123; register int T; scanf("%d",&amp;T); while(T--) &#123; register int a,b,c,d,f,g,k; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); f=(a-1)/c+1,g=(b-1)/d+1; if(f+g&gt;k) puts("-1"); else printf("%d %d\n",k-g,g); &#125; return 0;&#125; $B$ 如果没有楼梯使得上下两层房间连通，显然答案为$n$ 如果有楼梯使得上下两层房间连通，可以考虑贪心 显然从两边往中间寻找楼梯，答案一定最优（雾 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;char s[1001];int main () &#123; register int T; scanf("%d",&amp;T); while(T--) &#123; register int n,flag=false; scanf("%d%s",&amp;n,s+1); for(register int i=0;i&lt;=(n-1)/2;++i) if(s[i+1]=='1'||s[n-i]=='1') &#123; printf("%d\n",(n-i)&lt;&lt;1); flag=true; break ; &#125; if(!flag) printf("%d\n",n); &#125; return 0;&#125; $C$ 先吐槽一句这道题，真$TM$拖节奏+崩心态 一眼扩展欧几里得解同余方程，但是早就忘得差不多了 直接拿了之前的板子，大力调一波交上去就$WA$ 发现可能会爆$long$ $long$，改成__$int128$怒提一发$CE$ 最后改成暴力枚举就过了？？？不过最后评测的时候还是$TLE$ 这道题前前后后总共花了大概$1h$，最后还没做出来 回过头来看看这道题，发现还是比较妙的 先扔一个结论，如果方程有解，那么在$y \leq w$范围内一定有解 考虑证明，假设存在$y’=aw+b(a \ge 1,0 \leq b &lt; w)$使得$xw+y’d=p$ 即$xw+(aw+b)d=xw+awd+bd=(x+ad)w+bd$ 观察这个式子左右两项，左边的系数和为$x+aw+b$，右边的系数为$x+ad+b$ 因为$w&gt;d$，所以在$y \leq w$范围内$x+y$一定最小，得证 在$[0,w)$范围内枚举$y$，计算是否存在合法的$x$即可 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main () &#123; register long long n,p,w,d,z=0; scanf("%lld%lld%lld%lld",&amp;n,&amp;p,&amp;w,&amp;d); for(register long long i=0;i&lt;w;++i) if((p-i*d)%w==0) &#123; register long long x=(p-i*d)/w; if(x&gt;=0&amp;&amp;x+i&lt;=n) printf("%lld %lld %lld\n",x,i,n-x-i); else puts("-1"); z=1; break ; &#125; if(!z) puts("-1"); return 0;&#125; $D$ 不难发现合法的情况一定是一条链 枚举链首前两个节点的颜色计算即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200001;long long ans,tmp;int n,num,fir,seco,third;int c[maxn],in[maxn],to[maxn],re[maxn];int from[maxn],head[maxn],C[maxn][4];inline void add (int u,int v) &#123; from[++num]=head[u]; to[num]=v; head[u]=num;&#125;inline void dfs (int now,int fa,int pre) &#123; c[now]=6-c[fa]-c[pre],tmp+=C[now][c[now]]; if(ans&gt;tmp&amp;&amp;in[now]==1) &#123; for(register int i=1;i&lt;=n;++i) re[i]=c[i]; ans=tmp; return ; &#125; for(register int i=head[now];i;i=from[i]) if(to[i]!=fa) dfs(to[i],now,fa);&#125;int main () &#123; scanf("%d",&amp;n); ans=1e18; for(register int i=1;i&lt;=n;++i) scanf("%d",&amp;C[i][1]); for(register int i=1;i&lt;=n;++i) scanf("%d",&amp;C[i][2]); for(register int i=1;i&lt;=n;++i) scanf("%d",&amp;C[i][3]); for(register int i=1;i&lt;n;++i) &#123; register int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v),add(v,u); ++in[u],++in[v]; &#125; for(register int i=1;i&lt;=n;++i) if(in[i]&gt;=3) &#123; puts("-1"); return 0; &#125; for(register int i=1;i&lt;=n;++i) if(in[i]==1) &#123; fir=i; break ; &#125; seco=to[head[fir]]; for(register int i=head[seco];i;i=from[i]) if(to[i]!=fir) third=to[i]; c[fir]=1,c[seco]=2,tmp=C[fir][c[fir]]+C[seco][c[seco]],dfs(third,seco,fir); c[fir]=1,c[seco]=3,tmp=C[fir][c[fir]]+C[seco][c[seco]],dfs(third,seco,fir); c[fir]=2,c[seco]=1,tmp=C[fir][c[fir]]+C[seco][c[seco]],dfs(third,seco,fir); c[fir]=2,c[seco]=3,tmp=C[fir][c[fir]]+C[seco][c[seco]],dfs(third,seco,fir); c[fir]=3,c[seco]=1,tmp=C[fir][c[fir]]+C[seco][c[seco]],dfs(third,seco,fir); c[fir]=3,c[seco]=2,tmp=C[fir][c[fir]]+C[seco][c[seco]],dfs(third,seco,fir); printf("%lld\n",ans); for(register int i=1;i&lt;=n;++i) printf("%d ",re[i]); printf("\n"); return 0;&#125; $E$ 将$a$数组排序，依次更新最大值/最小值 每次更新出现次数更少的使得代价更小 最后记得特判不能完全更新的情况 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200001;int a[maxn],b[maxn],c[maxn];int main () &#123; register int n; register long long K; scanf("%d%lld",&amp;n,&amp;K); for(register int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); sort(a+1,a+n+1); register int tot=0; for(register int i=1;i&lt;=n;++i) &#123; if(a[i-1]==a[i]) ++c[tot]; else b[++tot]=a[i],++c[tot]; &#125; register int l=1,r=tot,L=c[l],R=c[r]; while(l&lt;r) &#123; if(L&lt;R) &#123; register int tmp=b[l+1]-b[l]; if((long long)L*tmp&lt;=K) K-=(long long)L*tmp,L+=c[++l]; else &#123; b[l]+=K/L; break ; &#125; &#125; else &#123; register int tmp=b[r]-b[r-1]; if((long long)R*tmp&lt;=K) K-=(long long)R*tmp,R+=c[--r]; else &#123; b[r]-=K/R; break ; &#125; &#125; &#125; printf("%d\n",b[r]-b[l]); return 0;&#125; $F$ 不难发现一些性质，对于每个点来说 如果它第一次不需要改变，那么它以后都不需要改变 如果它第$x(x \ge 2)$次不需要改变，那么它相邻的两个点第$x+1$次不需要改变 从第一次不需要改变的点开始递推，注意特判一些变化的情况即可 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;char s[200001];int vis[200001];queue &lt; int &gt; Q ;int main () &#123; register int k,n; scanf("%d%d%s",&amp;n,&amp;k,s); memset(vis,-1,sizeof(vis)); for(register int i=0;i&lt;n;++i) if(s[i]==s[(i+n-1)%n]||s[i]==s[(i+1)%n]) vis[i]=0,Q.push(i); while(!Q.empty()) &#123; register int x=Q.front(); Q.pop(); if(vis[(x+n-1)%n]==-1) vis[(x+n-1)%n]=vis[x]+1,Q.push((x+n-1)%n); if(vis[(x+1)%n]==-1) vis[(x+1)%n]=vis[x]+1,Q.push((x+1)%n); &#125; for(register int i=0;i&lt;n;++i) if(vis[i]==-1||vis[i]&gt;k) (k&amp;1)?putchar('B'+'W'-s[i]):putchar(s[i]); else (vis[i]&amp;1)?putchar('B'+'W'-s[i]):putchar(s[i]); printf("\n"); return 0;&#125; $G$ 考虑怎么构造排列使得$sum$最大/小 显然，当$p_i=q_i$时$sum$最小 贪心一下，发现当$p_i+q_i=n+1$时$sum$最大 如果$k&lt;(n+1)*n/2$，那么无解 如果$k \ge (n+1)*n/2$，考虑如何构造一种合法方案 首先使$p_i=i,q_i=i$，那么当前的$sum=(n+1)*n/2$ 贪心一下，每次在未被交换的值中选取最大的和最小的交换 这样交换，每次$sum$的增长一定最大 特判最后一次交换时$sum&gt;k$的情况即可 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int p[1000001],q[1000001];int main () &#123; register int n; register long long k; scanf("%d%lld",&amp;n,&amp;k); register long long minl=(long long)(n+1)*n/2,maxn=(n&amp;1)?-(n/2+1):0; for(register int i=n/2+1;i&lt;=n;++i) maxn+=(i&lt;&lt;1); if(k&lt;minl) &#123; puts("-1"); return 0 ;&#125; register long long ans=min(k,maxn),tmp=minl; for(register int i=1;i&lt;=n;++i) p[i]=i,q[i]=i; for(register int i=n;i&gt;(n+1)/2;--i) &#123; register int x=(i&lt;&lt;1)-(n+1); if(ans&gt;x+tmp) tmp+=x,swap(q[i],q[n-i+1]); else &#123; swap(q[i],q[tmp-ans+i]); break ; &#125; &#125; printf("%lld\n",ans); for(register int i=1;i&lt;=n;++i) printf("%d ",p[i]); printf("\n"); for(register int i=1;i&lt;=n;++i) printf("%d ",q[i]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>贪心</tag>
        <tag>图论</tag>
        <tag>模拟</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2015]小Z的房间]]></title>
    <url>%2F2019%2F10%2F06%2FHAOI2015-%E5%B0%8FZ%E7%9A%84%E6%88%BF%E9%97%B4%2F</url>
    <content type="text"><![CDATA[最近多校联考天天爆零搞得心态有点炸 某天联考有道矩阵树定理，然而我不会 所以就被一堆神仙爆踩了 后来觉得还是得补一补矩阵树定理，也算是涨个姿势 但是行列式真的好难啊 这题就是矩阵树定理模板题 首先把原图转换成基尔霍夫矩阵 对于每个点特判它上方的点和左边的点 如果是房间就可以连，如果是柱子就不能连 因为模数不是质数，所以高斯消元要用辗转相除法 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define mod 1000000000using namespace std;char s[11][11];int a[101][101],id[101][101];int main () &#123; register int m,n,num=0; scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=n;++i) scanf("%s",s[i]+1); for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) if(s[i][j]=='.') id[i][j]=++num; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) if(s[i][j]=='.') &#123; if(s[i-1][j]=='.') &#123; ++a[id[i-1][j]][id[i-1][j]]; ++a[id[i][j]][id[i][j]]; --a[id[i-1][j]][id[i][j]]; --a[id[i][j]][id[i-1][j]]; &#125; if(s[i][j-1]=='.') &#123; ++a[id[i][j-1]][id[i][j-1]]; ++a[id[i][j]][id[i][j]]; --a[id[i][j-1]][id[i][j]]; --a[id[i][j]][id[i][j-1]]; &#125; &#125; register long long ans=1; for(register int i=1;i&lt;num;++i) &#123; for(register int j=i+1;j&lt;num;++j) while(a[j][i]) &#123; register int x=a[i][i]/a[j][i]; for(register int k=i;k&lt;num;++k) &#123; register long long tmp=(long long)a[j][k]*x%mod; a[i][k]=((long long)a[i][k]-tmp+mod)%mod; &#125; swap(a[i],a[j]),ans=-ans; &#125; (ans*=a[i][i])%=mod,(ans+=mod)%=mod; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Matrix-Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2013]快餐店]]></title>
    <url>%2F2019%2F10%2F06%2FNOI2013-%E5%BF%AB%E9%A4%90%E5%BA%97%2F</url>
    <content type="text"><![CDATA[咕咕咕咕咕]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2014]KUR-Couriers]]></title>
    <url>%2F2019%2F09%2F25%2FPOI2014-KUR-Couriers%2F</url>
    <content type="text"><![CDATA[主席树都不会写迟早药丸 递归查询是否存在有严格众数的区间即可 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500005;int cnt,a[maxn],ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],sum[maxn&lt;&lt;5],root[maxn];inline void Modify (int &amp;now,int last,int l,int r,int pos) &#123; now=++cnt; sum[now]=sum[last]+1; if(l==r) return ; register int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) rs[now]=rs[last],Modify(ls[now],ls[last],l,mid,pos); else ls[now]=ls[last],Modify(rs[now],rs[last],mid+1,r,pos);&#125;inline int Query (int u,int v,int l,int r,int num) &#123; if(l==r) return (l+r)&gt;&gt;1; register int mid=(l+r)&gt;&gt;1; register int xl=sum[ls[v]]-sum[ls[u]],xr=sum[rs[v]]-sum[rs[u]]; if(xl&lt;=num/2&amp;&amp;xr&lt;=num/2) return 0; else if(xl&gt;num/2) return Query(ls[u],ls[v],l,mid,num); else if(xr&gt;num/2) return Query(rs[u],rs[v],mid+1,r,num);&#125;inline int read () &#123; char ch=getchar(); register int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;int main () &#123; register int n=read(),Q=read(); for(register int i=1;i&lt;=n;++i) a[i]=read(); for(register int i=1;i&lt;=n;++i) Modify(root[i],root[i-1],1,n,a[i]); while(Q--) &#123; register int l=read(),r=read(); printf("%d\n",Query(root[l-1],root[r],1,n,r-l+1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]与或和]]></title>
    <url>%2F2019%2F09%2F22%2FGXOI-GZOI2019-%E4%B8%8E%E6%88%96%E5%92%8C%2F</url>
    <content type="text"><![CDATA[一日双更休闲至极 考虑对矩阵中的数按二进制位计算贡献 对于$AND$运算，只有全$1$子矩阵有贡献 对于$OR$运算，只有全$0$子矩阵没有贡献 可以用单调栈做到$O(n^2)$计算贡献 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;int a[1001][1001],b[1001][1001],u[1001][1001],high[1001],wide[1001];inline long long clac (int n) &#123; register long long sum=0,top=0,res=0; for(register int i=1;i&lt;=n;++i) &#123; for(register int j=1;j&lt;=n;++j) &#123; u[i][j]=(b[i][j])?u[i-1][j]+1:0; register long long w=1,h=u[i][j]; while(top&amp;&amp;h&lt;=high[top]) sum-=high[top]*wide[top],w+=wide[top--]; high[++top]=h,wide[top]=w; sum+=w*h; res+=sum; &#125; sum=top=0; &#125; return res%mod;&#125;inline int read () &#123; char ch=getchar(); register int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;int main () &#123; register int n=read(),m=(n+1)*n/2; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) a[i][j]=read(); register long long g=0,f=0,num=(long long)m*m%mod; for(register int k=0;k&lt;32;++k) &#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) b[i][j]=(a[i][j]&gt;&gt;k)&amp;1; (f+=clac(n)*(1&lt;&lt;k)%mod)%=mod; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) b[i][j]^=1; (g+=(num-clac(n)+mod)*(1&lt;&lt;k)%mod)%=mod; &#125; printf("%lld %lld\n",f,g); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2015]荷马史诗]]></title>
    <url>%2F2019%2F09%2F22%2FNOI2015-%E8%8D%B7%E9%A9%AC%E5%8F%B2%E8%AF%97%2F</url>
    <content type="text"><![CDATA[$K$维哈夫曼树模板题 从小往大贪心即可 最底层记得补零 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define pa pair &lt; long long , int &gt;priority_queue &lt; pa , vector &lt; pa &gt; , greater &lt; pa &gt; &gt; Q ;inline long long read () &#123; char ch=getchar(); register long long num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;int main () &#123; register int n,k; scanf("%d%d",&amp;n,&amp;k); register long long ans=0; for(register int i=1;i&lt;=n;++i) Q.push(make_pair(read(),0)); while((n-1)%(k-1)!=0) ++n,Q.push(make_pair(0,0)); while(Q.size()&gt;=k) &#123; pa u=make_pair(0,0); for(register int i=1;i&lt;=k;++i) &#123; pa v=Q.top(); Q.pop(); u.first+=v.first; u.second=max(u.second,v.second+1); &#125; ans+=u.first; Q.push(u); &#125; printf("%lld\n%d\n",ans,Q.top().second); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2010]数字计数]]></title>
    <url>%2F2019%2F08%2F26%2FZJOI2010-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]墨墨的等式]]></title>
    <url>%2F2019%2F08%2F24%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E5%A2%A8%E5%A2%A8%E7%9A%84%E7%AD%89%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2006]皇帝的烦恼]]></title>
    <url>%2F2019%2F07%2F31%2FZJOI2006-%E7%9A%87%E5%B8%9D%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[今天打摆被抓有点烦 正解是二分+$DP$，但是先想想怎么贪心乱搞 可能相邻两个将军所需徽章数之和的最大值就是答案？？ 不难发现，当$n$为奇数时显然不成立 考虑每一种徽章最多可以给$\lfloor \frac {n} {2} \rfloor$个人 所以$ans$最大不会超过$\lceil \frac{\sum a[i]}{\lfloor \frac {n} {2} \rfloor} \rceil$ 最后把上面的两种情况取最大值即可 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int ans,sum,a[100001];inline int read () &#123; char ch=getchar(); int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;int main () &#123; register int n=read(); for(register int i=1;i&lt;=n;++i) a[i]=read(),sum+=a[i]; ans=a[1]+a[n]; for(register int i=1;i&lt;n;++i) ans=max(ans,a[i]+a[i+1]); ans=max(ans,(sum+(n&gt;&gt;1)-1)/(n&gt;&gt;1)); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2006]网络收费]]></title>
    <url>%2F2019%2F07%2F30%2FNOI2006-%E7%BD%91%E7%BB%9C%E6%94%B6%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[一道难度较大的树形$DP$思维题 考虑设$dp[i][j]$为以$i$节点为根，有$j$个$B$类叶子节点的子树的最小费用 对于每一对叶子节点$i$和$j$，它们的贡献$f_{i,j}$只会在它们的$Lca_{i,j}$上计算 那么可以把$f_{i,j}$先记录在它们的$Lca_{i,j}$上 然后考虑$dfs$维护$dp$，预处理出每个叶子节点可能产生的贡献 最后根据$A$和$B$两类叶子节点个数的限制，分情况进行转移即可 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int m,n,ans,tmp,t[1088],vis[12],c[1088][2],f[1088][12],dp[2102][1088];inline int read () &#123; char ch=getchar(); int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;inline int lca (int x,int y) &#123; for(register int i=n-1;i&gt;=0;--i) if((x&gt;&gt;i)^(y&gt;&gt;i)) return n-i-1;&#125;inline void dfs (int x,int dep,int l,int r) &#123; if(dep==n) &#123; dp[x][0]=c[x-m][0],dp[x][1]=c[x-m][1]; for(register int i=n-1;i&gt;=0;--i) dp[x][vis[i]^1]+=f[x-m][i]; return ; &#125; memset(dp[x],INF,sizeof(dp[x])); register int mid=(l+r)&gt;&gt;1; vis[dep]=0; dfs(x&lt;&lt;1,dep+1,l,mid),dfs(x&lt;&lt;1|1,dep+1,mid+1,r); for(register int i=0;i&lt;=mid-l+1;++i) for(register int j=0;j&lt;=r-mid&amp;&amp;i+j&lt;=r-l+1;++j) if(i+j&lt;=r-l-i-j+1) dp[x][i+j]=min(dp[x][i+j],dp[x&lt;&lt;1][i]+dp[x&lt;&lt;1|1][j]); vis[dep]=1; dfs(x&lt;&lt;1,dep+1,l,mid),dfs(x&lt;&lt;1|1,dep+1,mid+1,r); for(register int i=0;i&lt;=mid-l+1;++i) for(register int j=0;j&lt;=r-mid&amp;&amp;i+j&lt;=r-l+1;++j) if(i+j&gt;r-l-i-j+1) dp[x][i+j]=min(dp[x][i+j],dp[x&lt;&lt;1][i]+dp[x&lt;&lt;1|1][j]);&#125;int main () &#123; n=read(),m=1&lt;&lt;n; ans=INF; for(register int i=0;i&lt;m;++i) t[i]=read(); for(register int i=0;i&lt;m;++i) c[i][t[i]^1]=read(); for(register int i=0;i&lt;m-1;++i) for(register int j=i+1;j&lt;m;++j) tmp=read(),f[i][lca(i,j)]+=tmp,f[j][lca(i,j)]+=tmp; dfs(1,0,1,m); for(register int i=0;i&lt;=m;++i) ans=min(ans,dp[1][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LCA</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2003]智破连环阵]]></title>
    <url>%2F2019%2F07%2F30%2FNOI2003-%E6%99%BA%E7%A0%B4%E8%BF%9E%E7%8E%AF%E9%98%B5%2F</url>
    <content type="text"><![CDATA[最近颓得很，这道题写了整整三天 先去看了一下楼天城和朱泽园两位神仙的论文 被各种骚操作吊打得怀疑人生 首先每枚炸弹炸毁的武器应该是一段连续的区间 那么我们可以把武器划分成$ans$段 对于每一段武器，都用一枚炸弹去炸毁 现在我们考虑怎么样求出最小的$ans$ 直接搜索肯定超时，考虑剪枝优化 把每段武器看成一个点，每枚炸弹看成一个点 搜索的时候用二分图优化即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int m,n,k,ans,u[101],v[101],x[101],y[101],f[101],vis[101],step[101],ok[101][101],to[101][101];inline bool check (int a,int b)&#123; return (u[a]-x[b])*(u[a]-x[b])+(v[a]-y[b])*(v[a]-y[b])&lt;=k*k; &#125;inline bool find (int x) &#123; for(register int i=1;i&lt;=n;++i) if(!vis[i]&amp;&amp;ok[i][x]) &#123; vis[i]=true; if(!f[i]||find(f[i])) &#123; f[i]=x; return true; &#125; &#125; return false;&#125;inline int read () &#123; char ch=getchar(); int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;inline void dfs (int now,int sum) &#123; if(ans&lt;=sum+step[now]) return ; if(now&gt;m) &#123; ans=sum; return ; &#125; int g[101]; memcpy(g,f,sizeof(g)); for(register int i=now;i&lt;=m;++i) &#123; for(register int j=1;j&lt;=n;++j) if(check(j,i)&amp;&amp;to[j][now]&gt;=i) ok[j][sum+1]=true; memset(vis,false,sizeof(vis)); if(find(sum+1)) dfs(i+1,sum+1); for(register int j=1;j&lt;=n;++j) if(check(j,i)&amp;&amp;to[j][now]&gt;=i) ok[j][sum+1]=false; memcpy(f,g,sizeof(f)); &#125;&#125;int main () &#123; m=read(),n=read(),k=read(); ans=n; for(register int i=1;i&lt;=m;++i) x[i]=read(),y[i]=read(); for(register int i=1;i&lt;=n;++i) u[i]=read(),v[i]=read(); for(register int i=1;i&lt;=n;++i) for(register int j=m;j;--j) if(check(i,j)) to[i][j]=max(j,to[i][j+1]); for(register int i=1;i&lt;=m;++i) step[i]=INF; for(register int i=m;i;--i) for(register int j=1;j&lt;=n;++j) if(check(j,i)) step[i]=min(step[i],step[to[j][i]+1]+1); dfs(1,0); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2014]DOO-Around the world]]></title>
    <url>%2F2019%2F07%2F15%2FPOI2014-DOO-Around-the-world%2F</url>
    <content type="text"><![CDATA[摆了一天补篇题解可还行 先断环成链复制一遍，再前缀和预处理 显然终点都在$[n+1,2n]$中，把终点当作起点倒推 考虑设走$f[i]$步可以到达的最远的点为$fa[i]$ 如果当前所在点为$i$，找到可以到达的最远的点为$j$ 那么$f[i]=f[j]+1$，$fa[i]=fa[j]​$ 如果$i-fa[i]&gt;=n$，那么直接退出输出$f[i]$ 因为不存在一个更靠后的位置答案更优，证明不会 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2000002;int m,n,x,s,f[maxn],fa[maxn],sum[maxn];inline int read () &#123; char ch=getchar(); int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;int main () &#123; n=read(),s=read(); for(register int i=1;i&lt;=n;++i) &#123; int x=read(); m=max(m,x); fa[i]=i,sum[i]=sum[i-1]+x; &#125; for(register int i=n+1;i&lt;=(n&lt;&lt;1);++i) sum[i]=sum[i-1]+sum[i-n]-sum[i-n-1]; while(s--) &#123; register int i,j,d=read(); if(d&lt;m) puts("NO"); else for(i=n+1,j=1;i&lt;=(n&lt;&lt;1);++i) &#123; while(sum[i]-sum[j]&gt;d) ++j; f[i]=f[j]+1,fa[i]=fa[j]; if(i-fa[i]&gt;=n) &#123; printf("%d\n",f[i]); break ; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2008]硬币购物]]></title>
    <url>%2F2019%2F07%2F14%2FHAOI2008-%E7%A1%AC%E5%B8%81%E8%B4%AD%E7%89%A9%2F</url>
    <content type="text"><![CDATA[一边听课一边打摆 因为每次都做一次背包会$T$飞，考虑先不考虑限制预处理方案数 然后考虑限制，用总方案数减去不合法的方案数 第$i$种硬币要超出限制至少要用$d[i]+1$个 那么考虑限制之后不合法的方案数就是$F[s-c[i]*(d[i]+1)]$ 最后对硬币进行容斥，计算答案即可 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100007;int s,tot,c[4],d[4];long long f[maxn]=&#123;1&#125;;int main () &#123; for(register int i=0;i&lt;4;++i) scanf("%d",&amp;c[i]); for(register int i=0;i&lt;4;++i) for(register int j=c[i];j&lt;maxn;++j) f[j]+=f[j-c[i]]; scanf("%d",&amp;tot); while(tot--) &#123; for(register int i=0;i&lt;4;++i) scanf("%d",&amp;d[i]); scanf("%d",&amp;s); register long long ans=0; for(register int i=0;i&lt;16;++i) &#123; register int num=0; register long long sum=0; for(register int j=0;j&lt;4;++j) if(i&amp;(1&lt;&lt;j)) ++num,sum+=c[j]*(d[j]+1); if(s&lt;sum) continue ; ans+=(num&amp;1)?-f[s-sum]:f[s-sum]; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2010]能量采集]]></title>
    <url>%2F2019%2F07%2F14%2FNOI2010-%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[鸽子终于更博了 考虑设$F[i]$为$i$是$m$和$n$公因数的方案数，显然$F[i]=(m/i)*(n/i)$ 然后对$i$进行容斥，就能得到$F[i]$为$i$是$m$和$n$最小公因数的方案数 最后套用公式，直接计算答案即可 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;long long m,n,k,ans,f[100001];int main () &#123; scanf("%lld%lld",&amp;n,&amp;m); k=min(m,n); for(register int i=k;i;--i) &#123; f[i]=(n/i)*(m/i); for(register int j=i+i;j&lt;=k;j+=i) f[i]-=f[j]; (ans+=(i*2-1)*f[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3942]将军令]]></title>
    <url>%2F2019%2F04%2F26%2FLuogu3942-%E5%B0%86%E5%86%9B%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一道难度适中的小清新乱搞好题 这题的正解是贪心，不过我好像$Hack$了正解 贪心策略好像还是比较简单的 找到当前没被覆盖的深度最深的点 然后找到它的$K$级父亲，往周围标记距离在$K$以内的点 如果有更优的标记，即离每次开始标记的点更近 那么就暴力更新标记，知道全部的点都被标记为止 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200002;int n,k,t,ans,cnt,f[maxn],Q[maxn],fa[maxn],to[maxn],from[maxn],head[maxn];inline void add(int u,int v) &#123; from[++cnt]=head[u]; to[cnt]=v; head[u]=cnt;&#125;inline void bfs() &#123; Q[1]=1; fa[1]=1; int he=1,ta=2; while(he&lt;ta) &#123; int x=Q[he++]; for(register int i=head[x];i;i=from[i]) if(!fa[to[i]]) fa[to[i]]=x,Q[ta++]=to[i]; &#125;&#125;inline int read() &#123; char ch=getchar(); int num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;inline void update(int x) &#123; if(!fa[x]) return ; for(register int i=head[x];i;i=from[i]) if(f[x]-1&gt;f[to[i]]) &#123; f[to[i]]=f[x]-1; update(to[i]); &#125;&#125;int main() &#123; n=read(),k=read(),t=read(); for(register int i=1;i&lt;n;++i) &#123; int u=read(),v=read(); add(u,v); add(v,u); &#125; bfs(); memset(f,-1,sizeof(f)); for(register int i=n;i;--i) &#123; if(f[Q[i]]==-1) &#123; ++ans; int x=Q[i]; for(register int j=k;j;--j) x=fa[x]; f[x]=k; update(x); &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu3941]入阵曲]]></title>
    <url>%2F2019%2F04%2F26%2FLuogu3941-%E5%85%A5%E9%98%B5%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[一道难度适中的的小清新思维好题 我们先对原矩阵做一遍膜$K$意义下的前缀和 不难发现，膜$K$意义下前缀和相等的两个矩形 它们的前缀和的差一定是$K$的倍数 但是我们必须保证这两个矩形不重叠的部分一定是一个矩形 那么我们可以先枚举上下边界再枚举右边界 开一个桶依次记录膜$K$意义下的前缀和 最后根据每个数出现的次数计算贡献即可 特别要注意的是把桶清空的时候不能$memset$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;long long m,n,ans,mod;long long a[404][404],b[404],c[1000001];inline long long read() &#123; char ch=getchar(); long long num=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch^'0'),ch=getchar(); return num;&#125;int main() &#123; n=read(),m=read(),mod=read(); for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) a[i][j]=read(),(a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+mod)%=mod; for(register int i=0;i&lt;n;++i) for(register int j=i+1;j&lt;=n;++j) &#123; c[0]=1; for(register int k=1;k&lt;=m;++k) b[k]=(a[j][k]-a[i][k]+mod)%mod,ans+=c[b[k]]++; for(register int k=1;k&lt;=m;++k) c[b[k]]=0; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu4556]雨天的尾巴]]></title>
    <url>%2F2019%2F04%2F14%2FLuogu4556-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4%2F</url>
    <content type="text"><![CDATA[这题给我的第一感觉就是树链剖分$+$树上差分，然而我不会 事实上主流做法确实是树链剖分，复杂度$O$$($$n$$logn^2$$)$ 然而这题还可以线段树合并，复杂度$O$$($$n$$logn$$)$ 但是跑得比树链剖分慢一倍，别问我为什么常数那么大 直接对每一个节点都维护一颗权值线段树 再套一个树上差分，最后直接线段树合并 因为这题空间卡得紧，所以离线操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int M=100001;const int N=8000008;int w,cnt,num,d[N],l[N],r[N],t[N],to[M&lt;&lt;1],from[M&lt;&lt;1];int X[M],Y[M],Z[M],fa[M],ans[M],son[M],sum[M],top[M],deep[M],head[M],root[M];inline void add(int u,int v) &#123; from[++num]=head[u]; to[num]=v; head[u]=num;&#125;inline int read() &#123; char ch=getchar(); int c=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) c=(c&lt;&lt;3)+(c&lt;&lt;1)+(ch^'0'),ch=getchar(); return c;&#125;inline void update(int x) &#123; if(d[l[x]]&gt;=d[r[x]]) d[x]=d[l[x]],t[x]=t[l[x]]; else d[x]=d[r[x]],t[x]=t[r[x]];&#125;inline int merge(int a,int b,int x,int y) &#123; if(!a) return b; if(!b) return a; if(x==y) &#123; d[a]+=d[b]; t[a]=x; return a; &#125; int mid=(x+y)&gt;&gt;1; l[a]=merge(l[a],l[b],x,mid),r[a]=merge(r[a],r[b],mid+1,y); update(a); return a;&#125;inline void Dfs1(int x) &#123; sum[x]=1; int maxx=-1; for(register int i=head[x];i;i=from[i]) if(!deep[to[i]]) &#123; deep[to[i]]=deep[x]+1,fa[to[i]]=x; Dfs1(to[i]); sum[x]+=sum[to[i]]; if(sum[to[i]]&gt;maxx) maxx=sum[to[i]],son[x]=to[i]; &#125;&#125;inline void Dfs2(int x,int topx) &#123; top[x]=topx; if(!son[x]) return ; Dfs2(son[x],topx); for(register int i=head[x];i;i=from[i]) if(!top[to[i]]) Dfs2(to[i],to[i]);&#125;inline int LCA(int x,int y) &#123; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; return deep[x]&lt;deep[y]?x:y;&#125;inline int Change(int a,int x,int y,int pos,int val) &#123; if(!a) a=++cnt; if(x==y) &#123; d[a]+=val; t[a]=x; return a; &#125; int mid=(x+y)&gt;&gt;1; if(pos&lt;=mid) l[a]=Change(l[a],x,mid,pos,val); else r[a]=Change(r[a],mid+1,y,pos,val); update(a); return a;&#125;inline void ReDfs(int x) &#123; for(register int i=head[x];i;i=from[i]) if(deep[to[i]]&gt;deep[x]) ReDfs(to[i]),root[x]=merge(root[x],root[to[i]],1,w); if(d[root[x]]) ans[x]+=t[root[x]];&#125;int main() &#123; int n=read(),m=read(),x,y,z; for(register int i=1;i&lt;n;++i) x=read(),y=read(),add(x,y),add(y,x); deep[1]=1; Dfs1(1),Dfs2(1,1); for(register int i=1;i&lt;=m;++i) X[i]=read(),Y[i]=read(),Z[i]=read(),w=max(w,Z[i]); for(register int i=1;i&lt;=m;++i) &#123; int lca=LCA(X[i],Y[i]); root[X[i]]=Change(root[X[i]],1,w,Z[i],1),root[Y[i]]=Change(root[Y[i]],1,w,Z[i],1); root[lca]=Change(root[lca],1,w,Z[i],-1); if(fa[lca]) root[fa[lca]]=Change(root[fa[lca]],1,w,Z[i],-1); &#125; ReDfs(1); for(register int i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>LCA</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2019游记]]></title>
    <url>%2F2019%2F04%2F12%2FHNOI2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[省选结束了，大概是几家欢喜几家愁吧 $Day0$ 清明三天小长假的第一天，强制机房自习差评 心情有些烦，不太想做题，开始颓$PES$ 这种状态从没参加的安徽集训时开始，已经持续很久了 因为没人监督，所以颓得有点过分 有时候还和$Lyy$机房联机 半个月的时间就只搞了一点数学，成功把我搞自闭了 颓了一上午，下午捣鼓一下博客 晚上泊富吃饭，顺便逛了逛 回家之后没找到准考证，回学校机房找 最后准考证竟然是在我主机后面发现的 $Day1$ 早晨起得很早，去学校搭校车，竟然不是很困 校车迟到$10$分钟，问题不大 过去的路上是一个人坐，想一个人静一静 看着窗外熟悉的道路迷迷糊糊睡着了 醒来就快到$CSLG$了，司机飙车技术好评 刚睡醒有点困，赶紧灌了一口雀巢特浓 考场还是熟悉的考场，只不过这一次人好像少了许多 提前15分钟进考场，好像可以提前打配置 前面那一排用的都是$guide$，感觉很迷 开考之后先把题目看看了一遍，生怕开错题 没怎么仔细看所以看得很快 $T1$计算几何，$T2$字符串，$T3DP$ 决定先开$T2$，看了几遍题面确保没有读错题 撤销操作要查询历史版本，$KMP$套主席树 算了先码暴力$KMP$匹配，拿满暴力再说 突然发现自己忘了$KMP$怎么写 现场手推$KMP$可还行，这里可能浪费了两个小时 $T2$暴力写完还有两个多小时，心态没崩 接下来开$T1$，考前压根没复习计算几何 出去上个厕所呼吸一下新鲜空气 一堆人好像都还在爆肝$T1$？？？ 而且程序都莫名一样？？？ 怎么这么都多$for$循环？？？ 就这样我的思路被顺利地带偏了 又想了一下，好像可以枚举中轴线优化 好像有点难码，两个小时不一定能调出来 索性$O$$($$n^6$$)$，判角用的余弦定理 码完后死活调不出来，最后发现是$for$循环条件打错了 改完一发过样例，一看表还有$15$分钟 感觉这个$T3$不一定能骗得到分 拿出一堆零食，开始吃吃喝喝洗桑拿 吃着吃着就下考了，感觉今天发挥还算正常？？？ 出考场之后和大佬交流了一波 $Xmy$说$T1$可以$O$$($$n^2$$)$踩标算，$Lzk$说$T1$可以$O$$($$n^3$$)$吸氧卡常 我自闭了，这一个个都是要$AK$的节奏啊 下午回家睡不着觉，去$IFS$逛一逛 喝下午茶$+$看电影，调音师剧情好评 晚上听说成绩出了，就回机房去看一看 $T1$没挂分，$T2$爆零？？？ 后面发现我$T2$数组开小了。。。 特意看了一下，$Xmy$的$T1$只有$10$分，$Lzk$的$T1$只有$20$分 群里有人说他的$KMP$套主席树被卡到$20$分，$Xxz$的后缀自动机也只有$20$分 看来今天大家挂分都很严重 后排$6$人$generals$开黑可还行 问题不大，写了一下知乎回答，回家睡觉 $Day2$ 早上起早有些困，一上车就开始睡 睡醒就到了$CSLG$，还是困得不行 猛灌一大口雀巢特浓，全靠咖啡提神 还是先浏览了一遍题目，决定先开$T1$ $T1$感觉很迷，只能硬着头皮肝 没想出来什么暴力，最后深搜大剪枝 $T2$数论？？？题意好难理解 感觉这题出得太绕，出题人怕不是思维江化？？？ 稍微想了想，发现$n=1$的情况可以组合数计算贡献 然后开始码码码，码完自己手玩了几组样例 感觉正确就跳$T3$，$T3$感觉就像数据结构 深搜再用平均数剪一剪，感觉$10$分还是挺稳的 三题暴力码完大概还有$5$分钟，还是吃吃喝喝洗桑拿 不知不觉中我的第一次$HNOI$就这么结束了 下午回家吃完饭倒头就睡，一觉睡到五点 回学校机房看成绩，我今天爆零了？？？ 高二的学长有四个进队，好像$Jyx$也有希望进队？？？ $Zzs$把我们都赶回教室上晚自习，带着$Jyx$又去了$CSLG$ 晚自习和$Czz$聊得不亦乐乎，桌上作业堆得像山一样高 只写了语文数学，理性剪枝，怕是不想读书了 终于熬过了晚自习，跑到机房去了解一下情况 貌似后面又重测了一遍，还不分天算成绩？？？ $CCF$一年一个搞法？？？实在是不想吐槽$CCF$ $Jyx$貌似重测之后出队线了？？？不过应该有$D$吧 $T1$和$T3$挂了，因为今年$HNOI$的栈只有$8MB$ $T2$我至今没有找到$bug$，感觉最近码力直线下降 如果次次考试都这样挂分怕是真的要$AFO$ 毕竟马上我也快高二了，各种机会也都只有一次了 如果不想让自己后悔的话，那就自己好好努力吧 星光不问赶路人，时光不负有心人]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2019%2F04%2F05%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[明天就是省选，现在还在颓颓颓，珍惜最后的欢乐时光 $Day0$ 前一天晚上教练就作了安排，上午自习下午放假 不错不错，还算有点人性 一想起别人在考期中而我们在放假，还是比较开心的 上午主要就是看一看考试注意事项，$5$分钟就看完了 机房里面一堆人在打板子，看着就烦。。。 旁边$Zcy$喊我打$Slay$，人生第一次打$Slay$ 反正马上就考试了，也不在乎这些了 大考大玩，小考小玩 然后就这么颓废了一上午 中午我爸突然就过来了？？？ 本来下午还想出去玩的 在租的房子里睡了一个下午，现在睡觉都是一种奢侈 醒来之后从城北$CSYZ$跑到城南$MDZX$，去找$Jzh$ 请$Jzh$在外面吃了饭，再送他回学校上晚自习 $Jzh$还是一点也没没变，好兄弟一辈子 晚上回机房接着颓$Slay$ 我妈晚上也过来了，回家倒头就睡 可能白天颓得太狠，晚上有点失眠？？？ $Day1$ 起得特别早，到学校门口集合统一坐车前往$CSLG$ 老习惯又是一罐雀巢特浓顶着 上了车就开始奶人，旁边的$Wth$一度被我奶到怀疑人生 提前$20$分钟进了考场，第一次$NOIP$还是有点紧张的 监考老师提前$10$分钟给出了解压密码，然后我就解压开始写 $T1$正解不会，打的暴力 复杂度玄学，感觉没有这档分？？？ $T2$题意很难看懂啊，就是最少的数去凑全部的数 下意识就是一个暴搜？？？加上剪枝跑得飞快 $T3$有点懵，尝试骗分，鬼晓得我当时打了什么 出了考场就知道今天凉了，旁边一群大佬说什么今天大众分$255$ 下午又是睡一下午，晚上又去机房颓废一晚上 $Day2$ 路上不想奶人了，也没有那个心情 满脑子想的都是今天怎么翻盘 今天没有提前发解压密码，而且草稿纸一人只有一张，全程差评 $T1$又是暴搜，但是最后一个大样例死活过不去 鬼晓得$n$条边的情况就是暴力拆边。。。 $T2$我推了差不多两个小时，草稿纸早就没了 拿着一包纸巾打草稿可还行 差不多写完小半包纸巾，我感觉自己推出了一个$Fibonacci$。。。 当时也没仔细想就打了上去，乱推式子竟然没挂？？？ $T3$贪心过了大样例就不管了 总的来说发挥一般，考完之后心情还算好 下午去了趟$IFS$，记得上次来到这里还是中考结束 现在一转眼就半年了，半年的$OI$似乎很短暂，可能缘分也就到这里吧 考完强制滚粗补文化课，补到我都有点厌学 很多人$AFO$了,里面就有喊我颓$Slay$的$Zcy$ 我却踩线苟活下来了，那一刻心中真的是百感交集 他们天赋不比我差，也未必见得没我努力 那么能留下来的为什么就是我呢？我不知道 苟活者在淡红的血色中 会依稀看见微茫的希望 谨以此段缅怀那段一起为$NOIP2018$奋斗的岁月]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2006]超级英雄]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2006-%E8%B6%85%E7%BA%A7%E8%8B%B1%E9%9B%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2008]树的统计]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2014]力]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2014-%E5%8A%9B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Luogu4139]上帝和集合的正确用法]]></title>
    <url>%2F2019%2F04%2F05%2FLuogu4139-%E4%B8%8A%E5%B8%9D%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2165]Median Pyramid Hard]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2165-Median-Pyramid-Hard%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2163]Median Pyramid Easy]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2163-Median-Pyramid-Easy%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2002]营业额统计]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2002-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2369]Ants on a Circle]]></title>
    <url>%2F2019%2F04%2F05%2FAtCoder2369-Ants-on-a-Circle%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2017]礼物]]></title>
    <url>%2F2019%2F04%2F05%2FHNOI2017-%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2012]灾难]]></title>
    <url>%2F2019%2F04%2F05%2FZJOI2012-%E7%81%BE%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[$ZJOI$里面的小清新思维题，思路参考了一些大神的博客 首先每个节点死亡的条件就是指向它的所有食物都已经死亡 那么我们可以反向建图，每个点指向它的食物 既然保证这个图没有环，那么我们显然可以拓扑排序 然后我们继续思考，不难发现每个节点死亡的条件等价于它所有食物的$LCA$死亡 因为它所有食物的$LCA$已经死亡，所以它的所有食物也都会死亡 最后求一下所有子树大小的前缀和就行，这里记得要减去自身 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,sum,num1,num2;int to1[400004],to2[400004];int from1[400004],from2[400004];int head1[400004],head2[400004];int ans[100001],ind[100001],topo[100001];int f[100001][18],depth[100001],father[100001];inline void add1(int from,int to) &#123; from1[++num1]=head1[from]; to1[num1]=to; head1[from]=num1;&#125;inline void add2(int from,int to) &#123; from2[++num2]=head2[from]; to2[num2]=to; head2[from]=num2;&#125;inline int LCA(int x,int y) &#123; if(depth[x]&lt;depth[y]) swap(x,y); for(register int i=16;i&gt;=0;--i) if(f[x][i]!=0&amp;&amp;depth[f[x][i]]&gt;=depth[y]) x=f[x][i]; if(x==y) return y; for(register int i=16;i&gt;=0;--i) if(f[x][i]!=0&amp;&amp;f[y][i]!=0&amp;&amp;f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return father[x];&#125;inline void RMQ(int x) &#123; f[x][0]=father[x]; for(register int i=1;i&lt;=16;++i) f[x][i]=f[f[x][i-1]][i-1];&#125;inline void Build() &#123; depth[n+1]=1,father[n+1]=n+1; for(register int i=n;i;--i) &#123; int x=topo[i]; if(!head1[x]) &#123; add2(n+1,x),depth[x]=2; f[x][0]=n+1,father[x]=n+1; continue ; &#125; int lca=to1[head1[x]]; for(register int i=from1[head1[x]];i;i=from1[i]) lca=LCA(lca,to1[i]); depth[x]=depth[lca]+1,father[x]=lca; add2(lca,x),RMQ(x); &#125;&#125;inline void DPtree(int x) &#123; ans[x]=1; for(register int i=head2[x];i;i=from2[i]) DPtree(to2[i]),ans[x]+=ans[to2[i]];&#125;inline void Toposort() &#123; queue &lt; int &gt; Q; for(register int i=1;i&lt;=n;++i) if(!ind[i]) Q.push(i); while(!Q.empty()) &#123; int x=Q.front(); Q.pop(); topo[++sum]=x; for(register int i=head1[x];i;i=from1[i]) &#123; --ind[to1[i]]; if(!ind[to1[i]]) Q.push(to1[i]); &#125; &#125;&#125;int main() &#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; while(true) &#123; scanf("%d",&amp;m); if(!m) break ; else add1(i,m),++ind[m]; &#125; &#125; Toposort(); Build(); DPtree(n+1); for(register int i=1;i&lt;=n;++i) printf("%d\n",ans[i]-1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SHOI2011]双倍回文]]></title>
    <url>%2F2019%2F03%2F23%2FSHOI2011-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[又是一道回文自动机的好题 如果一个串是双倍回文串，一定满足两个条件 长度是4的倍数 有一个长度为它的长度一半的回文后缀 先预处理建立回文自动机，再枚举每一个节点 暴力跳$fail$指针，判断是否存在长度为它一半的回文后缀即可 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;char s[500005];int fail[500005];int len[500005];int ch[500005][26];int n,ans,tot,last;int main() &#123; scanf("%d%s",&amp;n,s+1); tot=1;fail[0]=1;len[1]=-1; for(register int i=1;i&lt;=n;++i) &#123; while(s[i-len[last]-1]!=s[i]) last=fail[last]; if(!ch[last][s[i]-'a']) &#123; len[++tot]=len[last]+2; int j=fail[last]; while(s[i-len[j]-1]!=s[i]) j=fail[j]; fail[tot]=ch[j][s[i]-'a']; ch[last][s[i]-'a']=tot; &#125; last=ch[last][s[i]-'a']; &#125; for(register int i=tot;i;--i) &#123; int j=i; if(len[i]%4&gt;0||len[i]&lt;=ans) continue ; while((len[j]&lt;&lt;1)&gt;len[i]) j=fail[j]; if(len[j]&lt;&lt;1==len[i]) ans=len[i]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[APIO2014]回文串]]></title>
    <url>%2F2019%2F03%2F23%2FAPIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[因为最近沉迷搞学科所以没有半个月没有更博 毫无疑问这题最简单的做法应该是回文自动机 暴力跳$fail$指针再顺便统计一下节点的个数 最后取最大值即可，就是一道$PAM$模板题 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;char s[300003];int n,tot,last;int cnt[300003];int len[300003];int fail[300003];int ch[300003][26];long long ans;int main() &#123; scanf("%s",s+1);n=strlen(s+1); tot=1;fail[0]=1;len[1]=-1; for(register int i=1;i&lt;=n;++i) &#123; while(s[i-len[last]-1]!=s[i]) last=fail[last]; if(!ch[last][s[i]-'a']) &#123; len[++tot]=len[last]+2; int j=fail[last]; while(s[i-len[j]-1]!=s[i]) j=fail[j]; fail[tot]=ch[j][s[i]-'a']; ch[last][s[i]-'a']=tot; &#125; last=ch[last][s[i]-'a']; ++cnt[last]; &#125; for(register int i=tot;i&gt;=2;--i) &#123; cnt[fail[i]]+=cnt[i]; ans=max(ans,(long long)len[i]*(long long)cnt[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CTSC2014]企鹅QQ]]></title>
    <url>%2F2019%2F02%2F26%2FCTSC2014-%E4%BC%81%E9%B9%85QQ%2F</url>
    <content type="text"><![CDATA[这道题是一道哈希的裸题 其实学长之前上课讲哈希的时候顺带讲过 只是当时我在干嘛？？？ 先把所有字符串的哈希值都预处理出来 然后枚举哪一位不一样 把所有字符串这一位前缀和后缀的哈希值加起来 最后判断刚才计算的哈希值是否相等并且统计答案即可 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int l,m,n,ans,now;char s[202];unsigned long long t[30003];unsigned long long _hash[30003][202];unsigned long long hash_[30003][202];int main()&#123; scanf("%d%d%d",&amp;n,&amp;l,&amp;m); for(register int i=1;i&lt;=n;++i) &#123; scanf("%s",s+1); for(register int j=1;j&lt;=l;++j) _hash[i][j]=_hash[i][j-1]*223+s[j]; for(register int j=l;j&gt;=1;--j) hash_[i][j]=hash_[i][j+1]*233+s[j]; &#125; for(register int i=1;i&lt;=l;++i) &#123; for(register int j=1;j&lt;=n;++j) t[j]=_hash[j][i-1]*229+hash_[j][i+1]*239; sort(t+1,t+n+1);now=1; for(register int j=2;j&lt;=n;++j) t[j-1]==t[j]?ans+=now++:now=1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode873]Length of Longest Fibonacci Subsequence]]></title>
    <url>%2F2019%2F02%2F23%2FLeetCode873-Length-of-Longest-Fibonacci-Subsequence%2F</url>
    <content type="text"><![CDATA[考试的时候这道题直接看错了题意，后来看懂了之后就直接不会做 因为是$Fibonacci$，所以考虑$DP$ 可以设$F$$[$$i$$]$$[$$j$$]$为以$C$$[$$i$$]$为当前数，以$C$$[$$j$$]$为当前倒数第一个数的最大长度 我们可以考虑枚举$i$、$j$、$k$ 如果$C$$[$$i$$]$$=$$C$$[$$j$$]$$+$$C$$[$$k$$]$ 那么转移合法，$F$$[$$i$$]$$[$$j$$]$$=$$max$$($$F$$[$$i$$]$$[$$j$$]$$,$$F$$[$$j$$]$$[$$k$$]$$+$$1$$)$ 但是这样的复杂度就是$O$$($$n^3$$)$的，那么考虑优化 如果枚举$i$、$j$，那么$C$$[$$k$$]$$=$$C$$[$$i$$]$$-$$C$$[$$j$$]$是固定的 这里可以离散化和二分查找，时间复杂度是$log$级别的 然后再用$G$$[$$j$$]$$[$$i$$]$表示对于$C$$[$$k$$]$的最大值即可 那么总时间复杂度就是$O$$($$n^2$$logn$$)$的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,ans;int a[3333];int b[3333];int c[3333];int f[3333][3333];int g[3333][3333];inline int read()&#123; char ch=getchar();int c=0,f=1; while(!isdigit(ch)) &#123; if(ch=='-') f=0; ch=getchar(); &#125; while(isdigit(ch)) c=(c&lt;&lt;3)+(c&lt;&lt;1)+(ch^'0'),ch=getchar(); return f?c:-c;&#125;inline int Half(int z)&#123; int l=1,r=m,mid; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(a[mid]&gt;z) r=mid-1; else if(a[mid]&lt;z) l=mid+1; else return mid; &#125; return 0;&#125;int main()&#123; n=read(); for(register int i=1;i&lt;=n;++i) c[i]=read(),b[i]=c[i]; sort(b+1,b+n+1);a[++m]=b[1]; for(register int i=2;i&lt;=n;++i) &#123; if(b[i-1]==b[i]) continue ; a[++m]=b[i]; &#125; for(register int i=2;i&lt;=n;++i) for(register int j=1;j&lt;i;++j) &#123; f[j][i]=2; int k=Half(c[i]-c[j]); int l=Half(c[j]); f[j][i]=max(f[j][i],g[k][j]+1); ans=max(ans,f[j][i]); g[l][i]=max(g[l][i],f[j][i]); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>离散化</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HDU5763]Another Meaning]]></title>
    <url>%2F2019%2F02%2F23%2FHDU5763-Another-Meaning%2F</url>
    <content type="text"><![CDATA[话说这道题考场上把我弄自闭了 $KMP$板子有点忘记了，强行回忆了一波 然后突然发现不会计数。。。 不会$DP$的我就自闭了，其实这题$DP$式子不是一般的简单 先把子串的$Fail$指针预处理出来 然后在母串中匹配出子串的位置 最后进行$DP$计数，转移方程$F$$[$$i$$]$$=$$F$$[$$i-1$$]$$+$$F$$[$$i-m$$]$ 其中$i$是母串中成功匹配的位置，$m$为子串的长度 因为每匹配一次子串，都会带来新的意思，加上这个子串的方案数即可 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;char s[200002];char t[200002];int m,n,T;int f[200002];int fail[200002];int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%s%s",s+1,t+1); n=strlen(s+1);m=strlen(t+1); for(register int i=2;i&lt;=m;++i) &#123; int j=fail[i-1]; while(j&amp;&amp;t[j+1]!=t[i]) j=fail[j]; if(t[j+1]==t[i]) ++j; fail[i]=j; &#125; f[0]=1; for(register int i=1,j=0;i&lt;=n;++i) &#123; while(j&amp;&amp;s[i]!=t[j+1]) j=fail[j]; if(s[i]==t[j+1]) ++j; if(j==m) j=fail[j],f[i]=f[i-m]; f[i]+=f[i-1]; f[i]-=f[i]&gt;=mod?mod:0; &#125; printf("%d\n",f[n]); memset(f,0,sizeof(f)); memset(fail,0,sizeof(fail)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[IOI2000]回文字串]]></title>
    <url>%2F2019%2F02%2F23%2FIOI2000-%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[今天模拟赛三道动态规划，这是最简单的一道 考试的时候想的是贪心，大力分类讨论一波以为能过 考完才知道正解就是一道最长公共子序列？？？ 这个跟回文串的性质有关，它正着读和倒着读是完全一样的 这样的话我们就可以把原串反过来跟它自己匹配 最后的答案就是原串的长度减去匹配的长度 考完才发现我不会打最长公共子序列 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;char s1[10086];char s2[10086];int f[5005][5005];int n,ans;int main()&#123; scanf("%s",s1+1);n=strlen(s1+1); for(register int i=1;i&lt;=n;++i) s2[n-i+1]=s1[i]; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(s1[i]==s2[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); ans=n-f[n][n]; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]最长双回文串]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[学长讲过的$Manacher$例题，上课睡觉没听懂 开题的时候毫无思路，最后终于找到思路了 思路主要是枚举分界点，把这个点两边的最长回文串的长度拼起来 在每一次$Manacher$操作完成之后，我们可以顺便维护 以这个回文串的左端点为其左端点的最长回文串的长度 以这个回文串的右端点为其右端点的最长回文串的长度 事实上，这两个最长回文串的长度一定不小于这个回文串的长度 这样我们就可以在线性的时间复杂度里预处理出每个点左右的最长回文串的长度 预处理之后还要递推，大致就是不断地将之前回文串的长度$-$$2$取最大值 最后枚举每个#所在位置，不断更新$ans$取最大值 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;char s[222222];char t[222222];int p[222222];int l[222222];int r[222222];int n,k,o,ans;int main()&#123; scanf("%s",t+1);n=strlen(t+1); for(register int i=1;i&lt;=n;++i) s[i*2]=t[i],s[i*2+1]='#'; s[0]=s[1]='#';n=n*2+2;s[n]='\0'; for(register int i=0;i&lt;n;++i) &#123; p[i]=i&lt;o?min(o-i,p[k*2-i]):1; while(s[i+p[i]]==s[i-p[i]]) ++p[i]; if(i+p[i]&gt;o) k=i,o=i+p[i]; l[i+p[i]-1]=max(p[i]-1,l[i+p[i]-1]); r[i-p[i]+1]=max(p[i]-1,r[i-p[i]+1]); &#125; for(register int i=n-3;i&gt;0;i-=2) l[i]=max(l[i],l[i+2]-2); for(register int i=3;i&lt;n;i+=2) r[i]=max(r[i],r[i-2]-2); for(register int i=1;i&lt;n;i+=2) if(l[i]&amp;&amp;r[i]) ans=max(ans,l[i]+r[i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2567]RGB Sequence]]></title>
    <url>%2F2019%2F01%2F23%2FAtCoder2567-RGB-Sequence%2F</url>
    <content type="text"><![CDATA[先说几句题外话，这题是国家集训队作业 不过个人认为$AtCoder$上面的题质量真心不错 这题我硬是调了大半天，坑点还是有几个 而且这题竟然没有题解？？？赶紧过来水一发 这题正常人一眼过去就应该是$DP$，别告诉我你不是正常人 至于为什么显然是$DP$。。。方案数不是$DP$是什么？ 因为颜色的数量很少，只有三种 所以可以直接上三维$DP$，话说这好像还是我第一道三维$DP$ 所以我们可以用$f$ $[$ $i$ $]$ $[$ $j$ $]$ $[$ $k$ $]$来记录状态，统计方案数 $i$是当前枚举到的位置，$j$和$k$则分别是另外两种颜色最后出现的位置 建议将$j$设置为另外两种颜色靠后的那一种，枚举起来比较方便 然后思考状态转移方程，这里要分三种情况情况讨论 $i+1$位置上的颜色与$i$位置上的颜色一致 那么显然$j$和$k$的位置不变，$f$ $[$ $i+1$ $]$ $[$ $j$ $]$ $[$ $k$ $]$ $=$ $f$ $[$ $i$ $]$ $[$ $j$ $]$ $[$ $k$ $]$ $i+1$位置上的颜色与$j$位置上的颜色一致 那么$i$位置上的颜色就要后移一位，$f$ $[$ $i+1$ $]$ $[$ $i$ $]$ $[$ $k$ $]$ $=$ $f$ $[$ $i$ $]$ $[$ $j$ $]$ $[$ $k$ $]$ $i+1$位置上的颜色与$k$位置上的颜色一致 那么$i$和$j$位置上的颜色都要后移一位，$f$ $[$ $i+1$ $]$ $[$ $i$ $]$ $[$ $j$ $]$ $=$ $f$ $[$ $i$ $]$ $[$ $j$ $]$ $[$ $k$ $]$ 接下来我们以右端点为限制考虑贡献，这里脑补一下 根据$j$和$k$的大小关系判断区间内的颜色数量 不满足区间限制的直接赋值为0，不参与贡献 最后统计答案即可，这里要注意开$long$ $long$ 因为之前只是统计了区间内颜色数量而不是统计颜色方案数 就是之前没有计算区间内具体有什么颜色 所以统计答案之后一定要将$ans$乘以$3$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;int f[333][333][333];int m,n,l,r,x,ans,size;vector &lt; pair &lt; int , int &gt; &gt; rer[333];inline void update(int &amp;x,int y)&#123; x=((long long)1*x+y+mod)%mod; &#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=m;++i) &#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;x); rer[r].push_back(make_pair(l,x)); &#125; f[1][0][0]=1; for(register int i=1;i&lt;=n;++i) &#123; size=rer[i].size(); for(register int j=0;j&lt;size;++j) &#123; l=rer[i][j].first;x=rer[i][j].second; for(register int k=0;k&lt;i;++k) for(register int p=0;p&lt;=max(0,k-1);++p) &#123; if(x==1) &#123; if(l&lt;=k) f[i][k][p]=0; &#125; else if(x==2) &#123; if(k&lt;l||l&lt;=p) f[i][k][p]=0; &#125; else &#123; if(p&lt;l) f[i][k][p]=0; &#125; &#125; &#125; if(i==n) break ; for(register int j=0;j&lt;i;++j) for(register int k=0;k&lt;=max(0,j-1);++k) if(!f[i][j][k]) continue ; else &#123; update(f[i+1][j][k],f[i][j][k]); update(f[i+1][i][k],f[i][j][k]); update(f[i+1][i][j],f[i][j][k]); &#125; &#125; for(register int j=0;j&lt;n;++j) for(register int k=0;k&lt;=max(0,j-1);++k) update(ans,f[n][j][k]); ans=((long long)3*ans)%mod; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder2557]Ball Coloring]]></title>
    <url>%2F2019%2F01%2F22%2FAtCoder2557-Ball-Coloring%2F</url>
    <content type="text"><![CDATA[不得不说一句，这题在$AtCoder$里算一道水题 但是我时间空间都被同桌巨佬爆踩，还是水得不行啊 首先分类讨论，假设我们把最大值的球涂成蓝色 最小值的球涂成红色，那么我们可以贪心 把每个袋子里面较大值的球涂成蓝色，较小值的球涂成红色 $O$ $($ $n$ $)$就可以求出红蓝球区间的最大差值的最小值 但是这样不一定能使$ans$最小，接着来看另一种情况 最小值的球也涂成蓝色，这样$Bmax$ $-$ $Bmin$就已经确定了 那么我们就要让红球的区间最大差值最小 所以我们可以在上面的基础上 按照$x$从小到大的顺序，把颜色依次翻转 在翻转的过程中$O$ $($ $n$ $)$求出红球区间的最大差值的最小值 最后我们只要把两种答案再取最小值，就是最后的$ans$ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define INF 1000000007using namespace std;struct sakura&#123; long long x; long long y;&#125;ball[222222];long long x[222222];long long y[222222];long long maxn[222222];long long minl[222222];long long n,ans,ans1,ans2,bmax,bmin,rmax,rmin;inline bool cmp(sakura xx,sakura yy)&#123; return xx.x&lt;yy.x; &#125;int main()&#123; scanf("%lld",&amp;n); bmax=rmax=-1;bmin=rmin=INF; for(register int i=1;i&lt;=n;++i) &#123; scanf("%lld%lld",&amp;x[i],&amp;y[i]); if(x[i]&gt;y[i]) swap(x[i],y[i]); ball[i].x=x[i];ball[i].y=y[i]; bmax=max(bmax,y[i]); bmin=min(bmin,y[i]); rmax=max(rmax,x[i]); rmin=min(rmin,x[i]); &#125; ans1=(bmax-bmin)*(rmax-rmin); bmin=rmin;sort(ball+1,ball+n+1,cmp); ans2=INF;maxn[1]=minl[1]=ball[1].y; for(register int i=2;i&lt;=n;++i) &#123; maxn[i]=max(maxn[i-1],ball[i].y); minl[i]=min(minl[i-1],ball[i].y); if(i!=n) ans2=min(ans2,max(maxn[i],ball[n].x)-min(minl[i],ball[i+1].x)); &#125; ans2*=(bmax-bmin);ans=min(ans1,ans2); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu1361]小M的作物]]></title>
    <url>%2F2019%2F01%2F15%2FLuogu1361-%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9%2F</url>
    <content type="text"><![CDATA[最近学习网络流，感觉代码都巨长 网络流的题目无非都是一个套路 就是首先建模，然后随便套套模板 但是这题显然没有这么简单 一开始各种乱想，反正没想到最小割 然后随手点了一发题解，借鉴学习一下大神的思路 然后就TM恍然大悟，原来就是求最小割 最小割 $=$ 最大流 按照大神的思路，把$A$田地当做源点 $B$田地当做汇点，把$n$种植物当做中间点 没有最大收益的时候就直接连接源点、汇点和中间点 加上最大收益后，有些点就像是被捆绑在了一起 我们可以在这$m$个点集和源点、汇点之间， 再设置$2m$个中间点，把这些点和源点、汇点和中间点连接在一起 最大流量就是增加的收益 听起来真的很绕，但是真的是这样 题目要求最大收益，其实就是总收益 $-$ 最小割 剩下的部分，似乎直接上模板就差不多了 然而我$TM$直接$TLE$直接飞起 这题好像要优化一点点，至少朴素的$Dinic$模板不行 又是一位大神告诉我一个玄学优化 真$TM$一手骚操作，瞬间就切掉 这个不是我的东西我就先不讲了哈 自我感觉码风美好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define INF 99999999using namespace std;struct XM&#123; int to; int dis; int from;&#125;edge[4000004];int cur[40004];int deep[40004];int head[40004];int m,n,s,k,t,x,y,z,ans,num=-1;inline void add(int from,int to,int dis)&#123; edge[++num].from=head[from]; edge[num].to=to; edge[num].dis=dis; head[from]=num;&#125;inline bool Bfs()&#123; memset(deep,0,sizeof(deep)); queue &lt; int &gt; Q; while(!Q.empty()) Q.pop(); Q.push(s);deep[s]=1; while(!Q.empty()) &#123; int u=Q.front(); Q.pop(); for(register int i=head[u];i!=-1;i=edge[i].from) &#123; int v=edge[i].to; if(deep[v]==0&amp;&amp;edge[i].dis&gt;0) &#123; deep[v]=deep[u]+1; Q.push(v); &#125; &#125; &#125; if(deep[t]!=0) return true; else return false;&#125;inline int Dfs(int u,int f)&#123; if(u==t) return f; int sum=0; for(register int &amp;i=cur[u];i!=-1;i=edge[i].from) &#123; int v=edge[i].to; if(deep[v]==deep[u]+1&amp;&amp;edge[i].dis&gt;0) &#123; int d=Dfs(v,min(f,edge[i].dis)); if(d&gt;0) &#123; sum+=d;f-=d; edge[i].dis-=d; edge[i^1].dis+=d; if(!f) break; &#125; &#125; &#125; return sum;&#125;int main()&#123; scanf("%d",&amp;n); s=n+1;t=s+1; memset(head,-1,sizeof(head)); for(register int i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;x); ans+=x; add(s,i,x); add(i,s,0); &#125; for(register int i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;x); ans+=x; add(i,t,x); add(t,i,0); &#125; scanf("%d",&amp;m); for(register int i=1;i&lt;=m;++i) &#123; scanf("%d%d%d",&amp;k,&amp;x,&amp;y); ans+=x;ans+=y; add(s,n+i+2,x); add(n+i+2,s,0); add(n+m+i+2,t,y); add(t,n+m+i+2,0); for(register int j=1;j&lt;=k;++j) &#123; scanf("%d",&amp;z); add(n+i+2,z,INF); add(z,n+i+2,0); add(z,n+m+i+2,INF); add(n+m+i+2,z,0); &#125; &#125; while(Bfs()) &#123; memcpy(cur,head,sizeof(cur)); ans-=Dfs(s,INF); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
</search>
