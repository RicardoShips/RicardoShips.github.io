<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[USACO1.2]方块转换 Transformations]]></title>
    <url>%2F2019%2F02%2F19%2FUSACO1-2-%E6%96%B9%E5%9D%97%E8%BD%AC%E6%8D%A2-Transformations%2F</url>
    <content type="text"><![CDATA[一道大模拟又被我打出了160行 还好一次A掉不至于当场去世 毫无技术含量可言 只要基本懂字符串就行 首先，翻转$90$、$180$、$270$其实等于一个操作 就是写一个翻转$90$函数用三遍而已 翻转转移方程可以手玩一下 就是$s$[$i$] [$j$]=s[$n$-$j$+$1$][$i$]，还是比较好推的 然后写一次对称过来，再用三次翻转$90$函数 最后再看是不是和初始状态相同 建议每变化一次就去验证一次 如果成功就直接$return$ $0$，简单粗暴 下面一些题外话 大家做这种题一定要细心 哪怕你压行也要尽量控制代码长度 不然考场上真的很难查错，也很浪费时间 本人天生反面教材 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;using namespace std;char s[11][11];char x[11][11];char y[11][11];char z[11][11];bool flag;int n,ans;inline void C()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) y[i][j]=x[n-j+1][i];&#125;inline void M()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) x[i][j]=y[i][j];&#125;inline void V()&#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) y[i][j]=x[i][n-j+1];&#125;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) &#123; for(register int j=1;j&lt;=n;++j) &#123; cin&gt;&gt;s[i][j]; x[i][j]=s[i][j]; &#125; getchar(); &#125; for(register int i=1;i&lt;=n;++i) &#123; for(register int j=1;j&lt;=n;++j) cin&gt;&gt;z[i][j]; getchar(); &#125; C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("1"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("2"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("3"); return 0; &#125; else &#123; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) x[i][j]=s[i][j]; &#125; V();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("4"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; else M(); C();flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(y[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) &#123; puts("5"); return 0; &#125; flag=true; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(s[i][j]!=z[i][j]) &#123; flag=false; break; &#125; if(flag) puts("6"); else puts("7"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO1.1]坏掉的项链Broken Necklace]]></title>
    <url>%2F2019%2F02%2F19%2FUSACO1-1-%E5%9D%8F%E6%8E%89%E7%9A%84%E9%A1%B9%E9%93%BEBroken-Necklace%2F</url>
    <content type="text"><![CDATA[话说$USACO$的水题质量挺高的，好像真的是这样 这道题当时我可是调了一个下午的 这题暴力能过，复杂度就懒得算了 不需要什么思路，直接上模拟 就是枚举断开位置，然后分别往两边找 找到不能再找就停下，看看是否可以更新答案 需要特别提醒的是断开位置两边是$w$的情况 那就需要继续找到第一个不是$w$的位置 用这个位置上的字符去判断 然后就被我硬生生的打出了一道大模拟 别人平均$60$行，我打出了$160$行？？？ 心态崩了，我要妹子 看来我还是太菜了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;char a,b;char s[404];bool t[404];int n,l,r,ans,sum;int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;++i) cin&gt;&gt;s[i]; memset(t,false,sizeof(t)); a=s[1];b=s[n]; if(a=='w') &#123; for(register int i=1;i&lt;=n;++i) if(s[i]!='w') &#123; a=s[i]; break; &#125; &#125; if(b=='w') &#123; for(register int i=n;i&gt;=1;--i) if(s[i]!='w') &#123; b=s[i]; break; &#125; &#125; for(register int i=1;i&lt;=n;++i) if(s[i]==a||s[i]=='w') t[i]=true; else break; for(register int i=n;i&gt;=1;--i) if(s[i]==b||s[i]=='w') t[i]=true; else break; for(register int i=1;i&lt;=n;++i) if(t[i]) ++ans; for(register int i=1;i&lt;=n-1;++i) &#123; memset(t,false,sizeof(t)); a=s[i];b=s[i+1];sum=0; if(a=='w') &#123; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; else &#123; for(register int k=n;k&gt;=i+1;--k) if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; a=s[j]; break; &#125; &#125; &#125; &#125; if(b=='w') &#123; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; else &#123; for(register int k=1;k&lt;=i;++k) if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; else &#123; if(s[j]!='w') &#123; b=s[j]; break; &#125; &#125; &#125; &#125; for(register int j=i;j&gt;=1;--j) &#123; if(j==1) &#123; if(s[j]==a||s[j]=='w') &#123; t[j]=true; for(register int k=n;k&gt;=i+1;--k) if(s[k]==a||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==a||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=i+1;j&lt;=n;++j) &#123; if(j==n) &#123; if(s[j]==b||s[j]=='w') &#123; t[j]=true; for(register int k=1;k&lt;=i;++k) if(s[k]==b||s[k]=='w') t[k]=true; else break; &#125; else break; &#125; else &#123; if(s[j]==b||s[j]=='w') t[j]=true; else break; &#125; &#125; for(register int j=1;j&lt;=n;++j) if(t[j]) ++sum; ans=max(ans,sum); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
